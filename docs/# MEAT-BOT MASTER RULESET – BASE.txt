Weiter zum Inhalt
Chatverlauf

Du:
Hey, kennst du den Agent builder? is das nciht genau das tool, das ich bruahce um chatGPT in meinen Bot einzubauen?
Und noch eine frage, man kann im tool ja sagen, nutze diese scripts bzw durchsuche sie, und antworte dann. Kann man diese scripts auch online zur verf√ºgung stellen, sodass ich diese live aktualisieren k√∂nnte?

Nachgedacht f√ºr 1m 49s
ChatGPT:
Kurzfassung vorab:

Ja, ich kenne den Agent Builder ‚Äì und er kann genau der ‚ÄûGehirn-Teil‚Äú f√ºr deinen Bot sein, aber er ersetzt nicht den Discord-/MEAT-Code.

‚ÄûSkripte/Docs live aktualisieren‚Äú geht, aber daf√ºr brauchst du sie als externen Tool-/API-Call, nicht nur als hochgeladene Datei.

Ich geh‚Äôs Schritt f√ºr Schritt durch.

1. Ist der Agent Builder ‚Äûdas Tool‚Äú, um ChatGPT in deinen Bot einzubauen?
Was der Agent Builder ist:

Ein visueller Canvas, auf dem du einen Agent-Workflow zusammenklickst:
Modelle, Tools, Guardrails, Knowledge, Routing etc. 
OpenAI Plattform
+1

Du kannst den fertigen Agent dann:

direkt in der OpenAI-Platform laufen lassen,

oder ihn als TypeScript/Python-Code exportieren, basierend auf dem Agents SDK. 
composio.dev
+1

Mit AgentKit/ChatKit kannst du diesen Workflow auch als Chat in dein eigenes Produkt einbetten. 
metaflow.life
+1

F√ºr deinen Discord-/MEAT-Bot bedeutet das:

Der Agent Builder k√ºmmert sich um Logik, Tools, Wissen, ‚ÄûWie denkt das Ding?‚Äú

Dein MEAT-Bot k√ºmmert sich weiter um:

Discord-Events (Slash-Commands, Buttons, Messages),

User-Handling, Berechtigungen, Sentinel, Stats usw.

Ein typischer Setup f√ºr dich w√§re:

Du baust deinen MEAT-AI-Agent im Agent Builder (mit Regeln, Tools, ggf. Knowledge).

Du exportierst den Agent als TypeScript-Agent-SDK-Code.

Diesen Code h√§ngst du in deinem Projekt z. B. an so etwas wie
src/bot/functions/ai/ai.service.ts dran, wo du:

eine Funktion antworteMitAgent(...) hast,

die von deinen Discord-Handlern (ai.command.ts oder ai.message.ts) aufgerufen wird.

Kurz: Ja, er ist sehr nah an dem, was du suchst, aber du brauchst trotzdem den Discord-Teil im MEAT-Bot selbst. Agent Builder ist eher die Agent-Engine, nicht der komplette Bot.

2. ‚ÄûNutze diese Skripte / durchsuche sie‚Äú ‚Äì kann ich die online hosten und live updaten?
Hier musst du zwei Welten unterscheiden:

A) Hochgeladene Dateien / Knowledge in der OpenAI-Platform
Im Agent Builder kannst du Dokumente / Knowledge hochladen, die der Agent dann durchsucht. 
Medium
+1

Diese Uploads sind aber im Prinzip Snapshots:

Wenn du deine Skripte √§nderst, musst du eine neue Version hochladen.

Das ist super f√ºr ‚Äûstabile Doku‚Äú, aber nicht optimal, wenn du st√§ndig live Code/Docs √§nderst.

‚û°Ô∏è Live-√Ñnderungen nur durch Repo-Commit ‚Üí automatisch aktualisierte Knowledge geht so nicht out of the box.

B) Externe Tools / MCP / eigene APIs ‚Üí ‚Äûlive‚Äú Docs & Skripte
Wenn du willst, dass der Agent immer den aktuellen Stand deiner Skripte/Docs hat, ist der richtige Weg:

Du stellst deine Skripte/Docs selbst bereit, z. B.:

per HTTP-API (Node/Express, Fastify etc.),

aus deiner Datenbank,

oder direkt aus GitHub/RAW, S3, deiner MEAT-Web-API usw.

Im Agent Builder definierst du ein Tool (oder MCP-Server), das diese API aufruft. 
OpenAI Plattform
+2
composio.dev
+2

Z. B. Tool get_meat_doc(path: string) ‚Üí ruft deine API auf ‚Üí liefert Text JSON zur√ºck.

Der Agent benutzt dieses Tool, wenn er etwas zu deinen Skripten wissen will.

Vorteil:

Du kannst deine Skripte/Dokumentation beliebig oft √§ndern,

der Agent holt sich bei jedem Aufruf einfach den aktuellen Stand von deinem Server.

F√ºr dich konkret (MEAT-Bot-Style):

Du k√∂nntest z. B. einen kleinen ‚ÄûDocs-Service‚Äú bauen, der:

deine MEAT-BOT MASTER RULESET ‚Äì BASE + weitere Docs aus dem Repo l√§dt,

per Endpoint z. B. /docs?path=... ausliefert,

optional ein eigenes Such-/RAG draufsetzt.

Im Agent Builder h√§ngt ein Tool meatDocs.search dran, das diesen Service anspricht.

Damit h√§ttest du:

Live updatbare Skripte/Regeln,

zentral weiter in deinem GitHub/Projekt gepflegt,

aber immer aktuell im Agent.

3. Was w√ºrde ich dir empfehlen (f√ºr MEAT)?
Wenn ich deine Struktur im Kopf behalte, w√ºrde ich:

AI-Agent im Agent Builder definieren

Persona + Regeln (z. B. ‚ÄûM.E.A.T.-Stil‚Äú),

Tools:

meatDocs.search (f√ºr Regeln/Tech),

ggf. discordTools (√ºber deine eigene API) f√ºr Stats/Serverinfos.

Den Agent per Agents SDK in deinen Bot einbauen

Exportierter TS-Code landet z. B. in
src/bot/functions/ai/ai.agent.ts.

Dein Discord-Handler (ai.command.ts) ruft dann einfach runAgentKonversation(...) aus dieser Datei auf.

Deine Skripte/Docs NICHT als Upload pflegen,
sondern √ºber eine eigene API / MCP-Server anbinden, die du aus dem Repo f√ºtterst.

So kannst du weiter in deinem Git-/MEAT-Setup arbeiten, und der Agent zieht sich immer das, was gerade ‚Äûlive‚Äú ist.

Wenn du magst, kann ich dir im n√§chsten Schritt eine konkrete Mini-Architektur f√ºr MEAT skizzieren (inkl. Dateipfaden wie src/bot/functions/ai/ai.command.ts + ai.service.ts + ‚ÄûAgent-Caller‚Äú), damit das sauber in deine bestehende Struktur passt.

Du:
Genau, den normalen bot brauche ich ja sowieso, aber dann kann ich die AI selbst ja √ºber das tool konfigurieren und dann via ts in meinem bot als function einbauen.
ich frage wegen den live dateien, wenn ich es schaffen w√ºrde, die daten oder einige davon upzudaten, dann k√∂nnte ich die ai ja mit strukturen, usern und und aus unserem discord f√ºttern. damit die ai auch immer weiss was abgeht und richtig antworten kann. oder kann ich das ding auch anders mit dem discord verkn√ºpfen, sodass die ki immer wei√ü was gibt es z.B. f√ºr channel und events etc
ChatGPT:

Nachgedacht f√ºr 2m 3s
Genau, du denkst in die richtige Richtung. üòä
Der ‚Äûnormale‚Äú MEAT-Bot bleibt der K√∂rper (Discord, Commands, Buttons, DB usw.), der Agent im Agent Builder ist das Gehirn ‚Äì und du f√ºtterst ihn mit Live-Daten aus deinem Discord.

Ich w√ºrde das so sehen:

1. Wie kommt ‚ÄûLive-Discord-Wissen‚Äú in die KI?
Es gibt im Prinzip zwei Layer, die du kombinieren kannst:

A) Kontext ‚Äûmitgeben‚Äú (Push-Modell)
Bei jedem Aufruf deines Agents schickst du zus√§tzlich:

guildId, channelId, userId

evtl. schon aufbereitete Infos:

Channel-Name, Kategorie, Topic

Liste relevanter Channels (z. B. nur ‚Äû√∂ffentliche‚Äú)

N√§chste Events, Montagsrunde, Tryhard-Donnerstag, etc.

Auszug aus eurem eigenen ‚ÄûMEAT-BOT MASTER RULESET ‚Äì BASE‚Äú

Das ist einfach: dein Slash-Command /ai holt sich die Daten √ºber discord.js / deine DB und packt sie in die input/context des Agents (Responses API oder Agents SDK). 
developers.openai.com
+1

Nachteil:
Du musst selbst entscheiden, was immer mitgeschickt wird. Wird die Payload gro√ü, wird‚Äôs un√ºbersichtlich/teurer.

B) Tools ‚Üí Agent fragt sich selbst Live-Daten aus Discord (empfohlen)
Hier kommt die Magie:
Mit dem Agents SDK kannst du Tools definieren, die dein Agent aufrufen darf. Tools sind einfach Funktionen, die z. B. deine Discord-Daten oder deine DB lesen. 
developers.openai.com
+1

Beispiele f√ºr solche Tools:

get_server_overview(guildId) ‚Üí Channels + Events + Rollen

get_user_profile(guildId, userId) ‚Üí Nickname, Rollen, interne Flags

get_active_events(guildId) ‚Üí z. B. Montagsrunde, Tryhard-Donnerstag aus deiner DB

get_bot_features(guildId) ‚Üí welche Module auf dem Server aktiv sind, Limits, etc.

Der Agent entscheidet dann selbst:

‚ÄûAh, ich soll was zu Events erkl√§ren ‚Üí ich rufe get_active_events auf.‚Äú

Das ist genau der Use Case, f√ºr den Tools im Agents SDK gebaut wurden. 
openai.github.io
+1

2. Wie sieht das praktisch mit deinem Discord-Bot aus?
Architektur-Idee f√ºr MEAT
Discord-Layer (hast du schon)

Slash-Commands, Buttons, Modals

Prisma, Sentinel, Polls, Montagsspiel usw.

AI-Layer (neu)

Agent im Agent Builder konfigurieren (Persona, Regeln, Tools).

Code via Agents SDK als TypeScript in dein Repo holen.

Agent bekommt Tools, die auf:

Discord (√ºber discord.js),

deine DB (Prisma),

oder ein eigenes ‚ÄûMEAT-Config-API‚Äú zugreifen.

Verkettung

/ai oder ein Message-Handler ruft eine Funktion runMeatAgent(...) auf.

Diese Funktion gibt dem Agent die User-Eingabe plus minimale IDs (guildId, userId, channelId).

Wenn der Agent mehr wissen will, ruft er deine Tools.

3. Konkretes Beispiel: Tool, das Channels & Events holt
‚ö†Ô∏è API-Details k√∂nnen je nach Agents-SDK-Version leicht anders aussehen ‚Äì das hier ist bewusst als Architektur-Beispiel gedacht, nicht 1:1 Copy-Paste.

Tool-Definition
Datei: src/bot/functions/ai/tools/discordTools.ts

import { tool } from "@openai/agents";
import { z } from "zod";
import type { Client } from "discord.js";

export function createDiscordTools(client: Client) {
  const getServerOverview = tool({
    name: "get_server_overview",
    description:
      "Gibt einen √úberblick √ºber Channels und geplante Events eines Discord-Servers.",
    parameters: z.object({
      guildId: z.string().describe("Die ID des Discord-Servers"),
    }),
    // Diese Funktion wird aufgerufen, wenn die KI das Tool benutzt
    execute: async ({ guildId }) => {
      const guild = await client.guilds.fetch(guildId);

      const channels = guild.channels.cache.map((channel) => ({
        id: channel.id,
        name: channel.name,
        type: channel.type,
        parentId: channel.parentId,
      }));

      const scheduledEvents = await guild.scheduledEvents.fetch();

      const events = scheduledEvents.map((event) => ({
        id: event.id,
        name: event.name,
        description: event.description,
        startAt: event.scheduledStartAt,
        endAt: event.scheduledEndAt,
        channelId: event.channelId,
      }));

      return {
        guildId,
        guildName: guild.name,
        channels,
        events,
      };
    },
  });

  return {
    getServerOverview,
  };
}
Die KI kann dann z. B. so ‚Äûdenken‚Äú (vereinfacht):

‚ÄûUser fragt: In welchem Channel ist das Event XY? ‚Üí Nutze get_server_overview ‚Üí analysiere Ergebnis ‚Üí antworte mit passendem Channel.‚Äú

4. Agent, der dieses Tool nutzt
Datei: src/bot/functions/ai/meatAgent.ts

import { Agent, Runner } from "@openai/agents";
import type { Client } from "discord.js";
import { createDiscordTools } from "./tools/discordTools.js";

export function createMeatAgent(client: Client) {
  const { getServerOverview } = createDiscordTools(client);

  const agent = new Agent({
    name: "MEAT-AI",
    model: "gpt-5.1",
    instructions: `
Du bist der KI-Kern von M.E.A.T.
- Du kennst die grundlegende Struktur des MEAT-Bots.
- Wenn du etwas √ºber Channels, Events oder Rollen wissen musst,
  nutze die verf√ºgbaren Tools, statt dir Dinge auszudenken.
    `.trim(),
    tools: [getServerOverview],
  });

  return agent;
}

export async function runMeatAgent(opts: {
  client: Client;
  guildId: string;
  userId: string;
  input: string;
}) {
  const agent = createMeatAgent(opts.client);

  const result = await Runner.run(agent, {
    input: opts.input,
    context: {
      // hier kannst du beliebige Zusatzinfos reinschieben
      guildId: opts.guildId,
      userId: opts.userId,
    },
  });

  return result.final_output;
}
5. Anbindung an deinen Discord-Command
Datei: src/bot/commands/ai/ask.ts

import type { ChatInputCommandInteraction } from "discord.js";
import { runMeatAgent } from "../../functions/ai/meatAgent.js";

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const question = interaction.options.getString("frage", true);

  const answer = await runMeatAgent({
    client: interaction.client,
    guildId: interaction.guildId!,
    userId: interaction.user.id,
    input: question,
  });

  await interaction.reply({
    content: answer,
  });
};
6. Live-Updates deiner ‚ÄûSkripte‚Äú / Regeln
Das gleiche Prinzip kannst du f√ºr deine eigenen Regeln/Skripte benutzen:

Halte deine MEAT-Regeln, Server-Struktur, Module, Limits in einer DB oder JSON-Config (oder in deinem Dashboard-Backend).

Bau ein Tool wie get_meat_config(guildId), das immer den aktuellen Stand zur√ºckgibt.

Der Agent ruft dieses Tool, wenn er z. B. wissen will:

Welche Module sind auf diesem Server aktiv?

Welche AI-Limits gelten?

Welche Kanal-Typen gibt es?

Damit musst du im Agent Builder keine statischen Dateien nachladen, sondern alles kommt live aus deinem eigenen System ‚Äì und du kannst es jederzeit √§ndern, ohne an der Agent-Konfiguration herumzuschrauben.

Kurz:

Ja, du kannst die KI so an deinen Discord ‚Äûandocken‚Äú, dass sie immer wei√ü, welche Channels & Events es gibt.

Der Schl√ºssel sind Tools, die √ºber deinen Bot/Backend die aktuellen Discord-Daten und deine eigenen Strukturen liefern.

Deine statischen Regeln (Lore, MEAT-Stil, Modul√ºbersicht) kannst du zus√§tzlich als Knowledge / API bereitstellen, damit der Agent immer im M.E.A.T.-Kosmos bleibt.

Wenn du willst, k√∂nnen wir im n√§chsten Schritt einmal ‚Äûausplanen‚Äú, welche Tools du f√ºr MEAT sinnvollerweise brauchst (get_server_overview, get_monday_poll, get_user_stats, get_vault_entries etc.), damit das gleich sauber in deine MEAT_MASTER_TREE_FINAL STRUCTURE passt.

Du:
ok! B) klingt genau so wie ich es haben will, und ich habe dann keinen aufwand damit. wie sieht es mitgenerellen contexten aus, kann der agent sind sachen merken bzw. kann ich auch da irgendwie was triggern oder session m√§√üig speichern?
Und wie sieht es auch wenn ein user jetzt sagt, nenn mich immer XY statt YX, kann er sich das merken? oder kann man bei sowas eine datei aktualisieren? wie geht das?
ChatGPT:

Nachgedacht f√ºr 2m 18s
Ja, genau so: B) + ein bisschen ‚ÄûMemory-Architektur‚Äú ‚Äì dann hast du quasi null manuellen Aufwand im Alltag. üòÑ
Ich teile das mal in zwei Themen: Kontext/Sessions und dauerhafte Erinnerungen (Nickname etc.).

1. Kann der Agent sich Sachen merken? (Sessions & Kontext)
a) Kurzfristiger Kontext (1 Chat / 1 Thread)
Sobald du den Agent mit dem Agents SDK nutzt, kannst du ihm eine Session geben.
Sessions = ‚ÄûChat-Verlauf‚Äú f√ºr genau diese Unterhaltung.

Im JS-SDK sieht das so aus: 
openai.github.io
+1

Datei: src/bot/functions/ai/meatAgentSession.ts

import { Agent, OpenAIConversationsSession, run } from "@openai/agents";

const meatAgent = new Agent({
  name: "MEAT-AI",
  instructions: "Du bist der M.E.A.T.-Assistent.",
});

export async function runMeatAgentWithSession(options: {
  session: OpenAIConversationsSession;
  input: string;
}) {
  const result = await run(meatAgent, options.input, {
    session: options.session,
  });

  return result.finalOutput;
}
Wichtig ist die Session:

const session = new OpenAIConversationsSession({
  // optional: explizite conversationId, z.B. "guildId:userId"
});
Wenn du bei jedem Bot-Call dieselbe Session benutzt (z. B. sessionId = guildId:userId oder guildId:channelId:userId), dann:

Holt das SDK beim n√§chsten Turn automatisch die alte History,

h√§ngt die neue User-Nachricht dran,

speichert nach der Antwort wieder alles ab. 
openai.github.io
+1

Der Agent ‚Äûwei√ü‚Äú dann im Gespr√§ch z. B. noch:

was der User eben gefragt hat,

dass ihr gerade √ºber ‚ÄûMontagsrunde‚Äú sprecht,

dass du schon erkl√§rt hast, was ein bestimmter Channel macht.

Das ist kurz- bis mittelfristiges Ged√§chtnis: so lange, wie die Session lebt (oder bis der Kontext getrimmt/zusammengefasst wird).

2. Dauerhafte Sachen: ‚ÄûNenn mich immer XY‚Äú & Co.
Jetzt zu deinem eigentlichen Wunsch:

‚ÄûWenn ein User sagt: nenn mich immer XY ‚Äì kann er sich das merken?‚Äú

Antwort:

Innerhalb einer Session vermutlich schon, einfach durch den Chat-Verlauf.

√úber Sessions und Neustarts hinweg solltest du das selbst persistieren ‚Äì z. B. mit Prisma/DB oder (notfalls) einer Datei.

a) Sauberer Weg: DB- oder File-Storage + Tool
Typisches Pattern mit dem Agents SDK:

Du baust ein Tool, das User-Preferences speichert (set_preferred_name)

Du baust ein Tool, das sie ausliest (get_user_profile)

In den Agent-Instructions steht:

Wenn der User sagt, wie du ihn nennen sollst, rufe set_preferred_name auf.

Dein Tool schreibt dann in deine DB / JSON-Datei; beim n√§chsten Gespr√§ch kann der Agent get_user_profile nutzen.

b) Beispiel: User-Prefs-Tool (Nickname speichern)
Datei: src/bot/functions/ai/tools/userPreferences.ts

import { tool } from "@openai/agents";
import { z } from "zod";

// Hier k√∂nntest du Prisma, Redis oder eine JSON-Datei verwenden.
// F√ºr das Beispiel nur ein In-Memory-Store:
const preferredNames = new Map<string, string>();

export const setPreferredNameTool = tool({
  name: "set_preferred_name",
  description:
    "Speichert den gew√ºnschten Rufnamen eines Discord-Users, damit er in Zukunft so angesprochen wird.",
  parameters: z.object({
    userId: z.string().describe("Discord User ID"),
    preferredName: z.string().describe("Gew√ºnschter Rufname"),
  }),
  async execute({ userId, preferredName }) {
    preferredNames.set(userId, preferredName);
    // In echt: hier z.B. Prisma-Update machen
    // await prisma.userPreference.upsert({ ... })

    return {
      success: true,
      message: `Name f√ºr User ${userId} wurde auf "${preferredName}" gesetzt.`,
    };
  },
});

export const getUserProfileTool = tool({
  name: "get_user_profile",
  description:
    "L√§dt gespeicherte User-Pr√§ferenzen, z.B. den gew√ºnschten Rufnamen.",
  parameters: z.object({
    userId: z.string().describe("Discord User ID"),
  }),
  async execute({ userId }) {
    const preferredName = preferredNames.get(userId) ?? null;
    // In echt: aus DB lesen
    // const row = await prisma.userPreference.findUnique({ where: { userId } })

    return {
      userId,
      preferredName,
    };
  },
});
In der echten MEAT-Version ersetzt du den Map-Store einfach durch Prisma (oder was du eh schon nutzt).

c) Agent so konfigurieren, dass er das Tool nutzt
Datei: src/bot/functions/ai/meatAgent.ts

import { Agent } from "@openai/agents";
import { setPreferredNameTool, getUserProfileTool } from "./tools/userPreferences.js";

export const meatAgent = new Agent({
  name: "MEAT-AI",
  model: "gpt-5.1",
  instructions: `
Du bist M.E.A.T., der Discord-Assistent.

- Wenn ein User dir sagt, wie du ihn nennen sollst
  (z.B. "Nenn mich bitte Hiro statt Herr Kr√§mer"),
  dann rufe das Tool "set_preferred_name" mit der Discord-User-ID und dem gew√ºnschten Namen auf.
- Bei Antworten kannst du optional "get_user_profile" nutzen, um den gespeicherten Rufnamen abzurufen.
`.trim(),
  tools: [setPreferredNameTool, getUserProfileTool],
});
Damit passiert folgendes:

User: ‚ÄûNenn mich bitte Hiro.‚Äú

Modell: ‚ÄûAh, das ist eine Pr√§ferenz‚Äú ‚Üí ruft set_preferred_name als Tool-Call auf.

Dein Code f√ºhrt das Tool aus ‚Üí speichert in DB/Datei.

Sp√§ter (auch in anderen Commands) kann die KI get_user_profile aufrufen und sieht:
preferredName = "Hiro".

d) Wie kommst du an userId & Session?
In deinem Discord-Command / Message-Handler baust du z. B.:

Datei: src/bot/commands/ai/ask.ts

import type { ChatInputCommandInteraction } from "discord.js";
import { meatAgent } from "../../functions/ai/meatAgent.js";
import { OpenAIConversationsSession, run } from "@openai/agents";

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const question = interaction.options.getString("frage", true);

  // Session pro User & Guild (kannst du auch anders w√§hlen)
  const session = new OpenAIConversationsSession({
    // z.B. "guildId:userId"
    conversationId: `${interaction.guildId}:${interaction.user.id}`,
  });

  const result = await run(meatAgent, question, {
    session,
    context: {
      discordUserId: interaction.user.id,
      guildId: interaction.guildId,
    },
  });

  await interaction.reply({
    content: result.finalOutput ?? "Keine Antwort erhalten.",
  });
};
üîß Wie kommt userId ins Tool?

Entweder du gibst dem Agent in den Instructions explizit:
‚ÄûDie Discord-User-ID findest du im Kontext unter discordUserId ‚Äì benutze sie bei Tools als userId.‚Äú

Oder du kapselst das nochmal in einem Wrapper, der im execute des Tools Zugriff auf den Run-Kontext hat und dort discordUserId einsammelt.

3. ‚ÄûKann ich daf√ºr auch einfach eine Datei aktualisieren?‚Äú
Ja, technisch ist das nichts anderes:

In setPreferredNameTool.execute statt Map machst du z. B.:

JSON-Datei einlesen,

Objekt anpassen,

Datei zur√ºckschreiben.

Aber:

Bei dir l√§uft MEAT-Bot perspektivisch auf Railway / Server etc.

Mehrere Instanzen, Crashs, Deploys ‚Üí JSON-Datei ist unsauber (Race Conditions, Locking, etc.).

Deshalb w√ºrde ich dir wirklich empfehlen:

Prisma + kleine UserPreference-Tabelle, z. B.:

model UserPreference {
  userId        String  @id
  preferredName String?
  // sp√§ter: language, optInTracking, etc.
}
Und die Tools set_preferred_name / get_user_profile rufen einfach Prisma auf.

Die Logik bleibt exakt gleich, nur dein Storage ist stabiler.

4. Fazit f√ºr deine Fragen
‚ÄûKann der Agent sich Sachen merken bzw. kann ich da was triggern oder session-m√§√üig speichern?‚Äú

Ja: Sessions geben dir automatisch Verlauf/Context pro User/Thread. 
openai.github.io
+1

Du kannst Sessions √ºber conversationId (= z. B. guild:user) steuern und so sehr genau festlegen, was zusammengeh√∂rt.

‚ÄûNenn mich immer XY statt YX‚Äú ‚Äì merkbar?

Innerhalb einer Session sowieso.

Dauerhaft: √ºber ein Tool, das deine eigene DB/Datei aktualisiert ‚Üí Agent nutzt dieses Tool selbstst√§ndig.

Du kannst also sowohl session-basierte Erinnerung (Verlauf) als auch persistent gespeicherte Pr√§ferenzen (Nickname, Sprache, Opt-ins) kombinieren.

Wenn du magst, k√∂nnen wir im n√§chsten Schritt konkret den Prisma-Teil bauen (Schema + userPreferences.ts mit echten DB-Queries), so dass du nur noch copy/pasten musst.

Du:
# MEAT-BOT MASTER RULESET ‚Äì BASE.txt
Dokument
ok geil!
schreib mir das zusammengefasst mit in mein master ruleset
und gib mir die datei komplett zur√ºcl

Nachgedacht f√ºr 2m 9s
ChatGPT:
// FILE: # MEAT-BOT MASTER RULESET ‚Äì BASE.txt

# MEAT-BOT MASTER RULESET ‚Äì BASE
Codename: CONSTRUCT-MEAT (Basis-Phase)

> Dieses Dokument definiert die Basis-Regeln f√ºr Struktur, Stil, Verhalten, Logging, Stats, Datenschutz, Web-Dashboard und Module des MEAT-Bots.  
> Nach einem Reset kann dieses Dokument an ChatGPT √ºbergeben werden, damit alle Regeln erneut gelten.

==================================================
0. RESET & VERWENDUNG MIT CHATGPT
==================================================

- Dieses Dokument dient als Referenz f√ºr alle zuk√ºnftigen Chats zu MEAT.
- Nach einem vollst√§ndigen Reset von ChatGPT:
  - Dieses Dokument wird erneut √ºbergeben.
  - Zus√§tzlich wird die aktuelle Projektstruktur (Ordner/Dateien) im Chat gezeigt.
  - ChatGPT h√§lt sich an:
    - diese Struktur,
    - diese Namenskonventionen,
    - diese Regeln zu Logging, Stats, Sentinel, Funktionen, Web-Dashboard etc.

- Wenn ChatGPT Code oder Dateien erzeugt:
  - Immer Dateipfad angeben, z. B.:
    - // FILE: src/bot/functions/poll/poll.command.ts
  - Dann Code in einem Codeblock.

==================================================
1. SPRACHE, TEXTE & GRUNDSTRUKTUR
==================================================

1.1 Sprache im Code & Kommentare
--------------------------------
- Der gesamte MEAT-Bot-Code ist Deutsch:
  - Funktions- und Variablennamen auf Deutsch: z. B. `berechnePunkte`, `ladeServerEinstellungen`, `erstelleEmbed`.
  - Kommentare sind deutsch und erkl√§ren kurz, warum etwas passiert.
- Externe APIs/Libraries (z. B. Discord.js) bleiben englisch, aber eigener Code folgt deutscher Benennung.

1.2 Texte f√ºr Embeds & Antworten (Mehrsprachigkeit)
---------------------------------------------------
- Es werden KEINE sichtbaren Texte direkt im Code hart verdrahtet:
  - keine Button-Beschriftungen,
  - keine Embed-Titel/-Texte,
  - keine Fehlermeldungen,
  - keine Modal-Texte.
- Stattdessen:
  - Jede Funktion hat eigene Text-JSONs im Funktionsordner:
    - `texte.de.json` (Pflicht, Standard-Deutsch),
    - sp√§ter optional weitere (z. B. `texte.en.json`).
  - Ein zentraler Text-Loader in `src/bot/general/texts/text-loader.ts` l√§dt Texte, z. B. `ladeTexte("poll", sprache)`.

- Standard-Sprache:
  - `de`.
- Fallback:
  - Wenn eine √úbersetzung fehlt, nutze Deutsch.

- Die Sprache pro Guild wird √ºber `serverSettings` gesteuert.

1.3 Grundstruktur bot/general vs bot/functions
----------------------------------------------
- Oberste Struktur (f√ºr den Bot):

  src/
    bot/         ‚Üí Haupt-Discord-Bot (MEAT)
    stream-bot/  ‚Üí separater Bot f√ºr Streaming-Funktionen (sp√§ter)
    web/         ‚Üí Web-Module/API/Dashboard (sp√§ter)

- Unter `src/bot/`:

  - `src/bot/general/` ‚Üí globale Mechanismen:
    - Config & Server-/User-/Global-Settings
    - Logging
    - Stats
    - Standard-Embeds & Styles
    - Icon-Registry
    - Text-Loader

  - `src/bot/functions/` ‚Üí jede Funktion / jedes Modul in eigenem Ordner:
    - z. B. `poll`, `stats`, `ai`, `connect`, `stream`, `video`, `randomizer`, `vault`, `sentinel/...`

1.4 Standard-Dateien pro Funktion
---------------------------------
Jede Funktion unter `src/bot/functions/<funktion>/` hat mindestens:

- `texte.de.json`          ‚Üí alle sichtbaren Texte f√ºr diese Funktion (Deutsch)
- `log.config.ts`          ‚Üí definiert, was/wie/wo geloggt wird
- `<funktion>.command.ts`  ‚Üí Einstieg √ºber Slash-Command (falls diese Funktion Commands hat)

Optionale, aber h√§ufige Dateien:

- `<funktion>.buttons.ts`  ‚Üí Button-Handler
- `<funktion>.modals.ts`   ‚Üí Modal-Handler
- `<funktion>.embeds.ts`   ‚Üí Funktions-spezifische Embed-Helfer
- `<funktion>.service.ts`  ‚Üí Services (DB, externe APIs, Berechnungen)
- `stats.config.ts`        ‚Üí welche Stats diese Funktion melden soll (optional, empfohlen)

1.5 Benennung (Variante 1 ‚Äì festgelegt)
---------------------------------------
- Ordner in `src/bot/functions/`:
  - technisch/englisch, `kebab-case`, z. B.:
    - `poll`, `stats`, `ai`, `connect`, `stream`, `video`, `randomizer`, `vault`, ...
- Dateinamen:
  - technisch/englisch, `kebab-case`:
    - `poll.command.ts`
    - `poll.buttons.ts`
    - `poll.embeds.ts`
    - `log.config.ts`
    - `texte.de.json`
    - usw.
- Innerhalb der Dateien:
  - Code & Kommentare deutsch.

1.6 Regeln f√ºr ChatGPT-Ausgaben
-------------------------------
Wenn ChatGPT Code f√ºr MEAT produziert:

- Kurze Erkl√§rung (1‚Äì3 S√§tze).
- IMMER Dateipfad angeben (Kommentar in der ersten Zeile).
- Danach Codeblock.

Au√üerdem:

- Stets zentrale Mechanismen ber√ºcksichtigen:
  - Logger,
  - Text-Loader,
  - Server-/User-/Global-Settings,
  - Icon-Registry,
  - Standard-Embeds & Styles.
- Sichtbare Texte kommen immer aus `texte.<sprache>.json`, niemals inline.

1.7 Bot-Persona (ohne GPT-Logic)
--------------------------------
- M.E.A.T. darf leicht frech / trashig sein bei normalen Antworten.
- Bei kritischen Themen:
  - Rollen & Rechte,
  - Systemeinstellungen,
  - Fehler & Warnungen,
  ist der Ton:
  - sachlich,
  - kurz,
  - klar verst√§ndlich.
- Standard-Antworten:
  - kompakt, keine Textw√§nde.
- Footer:
  - keine Pflicht f√ºr Witze; Footer eher f√ºr technische Infos oder Signaturen.

==================================================
2. TECH-STACK & CODE-STIL
==================================================

2.1 Runtime & TypeScript
------------------------
- Node.js:
  - mindestens aktuelle LTS (Node 20+).
- Produktivcode:
  - nur TypeScript im `src/`-Bereich.
- TypeScript-Konfiguration:
  - `strict: true`
  - `noImplicitAny: true`
  - `noUnusedLocals: true`
  - `noUnusedParameters: true`
  - `noFallthroughCasesInSwitch: true`

2.2 Modul-System & Imports
--------------------------
- Projekt ist ESM-only:
  - `type: "module"` in `package.json`
  - `moduleResolution: "node16"` oder `"nodenext"` in `tsconfig.json`
- Imports:
  - produktiver Code nutzt RELATIVE Imports mit `.js`-Endung:
    - Beispiel:
      - `import { erstelleStandardEmbed } from "../general/embed/create-standard-embed.js";`
- Exports:
  - grunds√§tzlich named exports:
    - `export function registrierePollCommand(...) { ... }`
    - `export const logger = ...;`
  - keine Default-Exports f√ºr Commands / Handler.

2.3 Code-Stil (ESLint + Prettier)
---------------------------------
- Einheitliches Linting & Formatting (ESLint, Prettier).
- Stil:
  - Semikolons: ja.
  - Einr√ºckung: 2 Spaces.
  - Strings: `'...'` (single quotes).
  - Maximale Zeilenl√§nge: ~100‚Äì120 Zeichen.
- Kommentare:
  - Deutsch,
  - kurz,
  - erkl√§ren ‚Äûwarum‚Äú, nicht nur ‚Äûwas‚Äú.
- Kein toter Code:
  - keine gro√üen auskommentierten Altbl√∂cke im Produktivcode.

2.4 Asynchronit√§t & Fehlerbehandlung
------------------------------------
- Asynchron:
  - `async/await`, keine verschachtelten `.then()`-Ketten.
- Externe Ressourcen (Discord, DB, Files, HTTP):
  - Try/Catch oder zentraler Error-Wrapper.
  - Fehler:
    - an zentralen Logger melden,
    - bei Bedarf kurze, sachliche User-Fehlermeldung (aus Texte-JSON).

2.5 Strukturelle Konventionen
-----------------------------
- Eine Datei = eine Hauptaufgabe:
  - `poll.command.ts` ‚Üí Slash-Command.
  - `poll.service.ts` ‚Üí interne Logik/DB.
- Gemeinsame Helper / Infrastruktur:
  - unter `src/bot/general/`:
    - Embeds,
    - Logging,
    - Stats,
    - Text-Loader,
    - Config,
    - Icons.
- Keine eigenen Mini-Systeme pro Funktion, wenn globale Mechanismen vorhanden sind.

2.6 Performance-Regeln
----------------------
- Grundsatz: MEAT soll performant und ressourcenschonend sein ‚Äì auch bei vielen Servern.
- Caching:
  - Server-/User-/Global-Settings werden gecacht und nur bei Bedarf neu geladen.
  - Texte (`texte.<sprache>.json`) und Icons werden beim ersten Zugriff geladen und wiederverwendet.
  - H√§ufig genutzte Daten (z. B. Listen von Dinos, LoL-Champions, Steam-Spielen) werden zentral gecacht.
- Debounce & Rate-Limits:
  - Bei schnellen wiederholten Aktionen (z. B. Button-Spam) werden:
    - Aktionen pro User/Funktion gedrosselt,
    - ggf. kurzzeitig blockiert (Soft-Rate-Limit).
- Lazy Loading:
  - Aufw√§ndige Operationen (z. B. externe API-Calls) werden nur ausgef√ºhrt, wenn tats√§chlich ben√∂tigt.
  - Nur die Teile eines Moduls werden geladen, die f√ºr eine konkrete Aktion gebraucht werden.
- API-Backoff:
  - Bei Fehlermeldungen externer APIs (Rate-Limits, Fehlercodes) werden:
    - Wiederholversuche gedrosselt oder verz√∂gert,
    - Fallback-Antworten an User geschickt (aus Texte-JSON).
- Stream-Bot & Web:
  - Polling/Abfragen werden so gestaltet, dass sie die DB/API nicht unn√∂tig belasten (Batching, Caching).

==================================================
3. PROJEKTSTRUKTUR
==================================================

3.1 Root-Struktur
-----------------
- Projektwurzel:

  src/
    bot/
    stream-bot/    (sp√§ter)
    web/           (sp√§ter)

  assets/
  logs/
  docs/
  scripts/

3.2 `src/bot/general/` ‚Äì globale Mechanismen
--------------------------------------------
- `src/bot/general/config/`
  - `server-settings-schema.ts`
  - `server-settings-loader.ts`
  - `user-settings-schema.ts`
  - `user-settings-loader.ts`
  - `global-settings-schema.ts`
  - `global-settings-loader.ts`
  - optional: `permissions-schema.ts`, `permissions-helper.ts`
- `src/bot/general/logging/`
  - `logger.ts`
  - `logging-helpers.ts`
- `src/bot/general/embed/`
  - `create-standard-embed.ts`
  - `module-styles.ts`
- `src/bot/general/icons/`
  - `icons.json` (Funktionsname ‚Üí Icon-Definition)
  - `icon-registry.ts`
- `src/bot/general/texts/`
  - `text-loader.ts`
- `src/bot/general/stats/`
  - `stats-manager.ts`
  - `stats-typen.ts`

3.3 `src/bot/functions/` ‚Äì Funktionen
-------------------------------------
- Jede Funktion hat einen eigenen Ordner unter `src/bot/functions/`.

- Beispiele f√ºr bestehende/geplante Funktionen:

  src/bot/functions/poll/                 ‚Üí Voting-/Poll-System (Montagsrunde etc.)
  src/bot/functions/stats/                ‚Üí Bot-/Server-/User-Statistiken & Serverprofil
  src/bot/functions/ai/                   ‚Üí KI-/Chat-Funktion (Erw√§hnungen, ‚Äû@MEAT‚Äú-Antworten)
  src/bot/functions/connect/              ‚Üí Zentrales Verkn√ºpfungsmodul (Twitch, YouTube, Steam, League, ‚Ä¶)
  src/bot/functions/stream/               ‚Üí Stream-/Ank√ºndigungslogik (nutzt `connect`-Daten)
  src/bot/functions/video/                ‚Üí Video-bezogene Funktionen (z. B. Clips, YouTube-Infos)
  src/bot/functions/randomizer/           ‚Üí Zufallsfunktionen: W√ºrfel, Coinflip, LoL-Champions, Teams, usw. (geplant)

  src/bot/functions/user/                 ‚Üí User-Profil, Stats-√úbersicht & Personalisierung (geplant)
  src/bot/functions/ranks/                ‚Üí Rank-/Level-/Achievement-System (eng verkn√ºpft mit `user` & `stats`, geplant)
  src/bot/functions/dinoname/             ‚Üí ARK Dino-Namensgenerator (sp√§ter mit DB & GPT)
  src/bot/functions/league/               ‚Üí League-of-Legends-Features (sp√§ter, nutzt `connect`)
  src/bot/functions/steam/                ‚Üí Steam-Profil, Releases, Trends (sp√§ter, nutzt `connect`)
  src/bot/functions/einbuergerung/        ‚Üí Einb√ºrgerungssystem / ‚Äûvirtuelle Nachbarn‚Äú (geplant)
  src/bot/functions/feedback/             ‚Üí Feedback-/Bug-Report-System (geplant)
  src/bot/functions/vault/                ‚Üí Vault / Wissens- & Snippet-Speicher (inkl. optionaler User-Notizen, geplant)

  src/bot/functions/events/               ‚Üí Erstellung & Verwaltung nativer Discord-Events (geplant)
  src/bot/functions/reminder/             ‚Üí Termin- & Erinnerungs-Funktion (inkl. Geburtstage, geplante Benachrichtigungen, geplant)

  src/bot/functions/sentinel/datenschutz/ ‚Üí Opt-in/Opt-out, Datenschutz-√úbersicht
  src/bot/functions/sentinel/spam/        ‚Üí Anti-Spam-Funktionen (geplant)
  src/bot/functions/sentinel/warnungen/   ‚Üí Warnsystem & Moderation (geplant)
  src/bot/functions/sentinel/raid/        ‚Üí Raid-Erkennung & Verteidigung (geplant)
  src/bot/functions/sentinel/monitoring/  ‚Üí System-Monitoring: Auslastung, Nutzung, Health-Checks (geplant)

- Diese Liste ist nicht abschlie√üend, dient aber als Merkzettel f√ºr zuk√ºnftige Module nach einem Reset.
- F√ºr alle neuen Funktionen gelten:
  - eigener Ordner,
  - Standard-Dateien (siehe 1.4),
  - Planung nach Checkliste (siehe Abschnitt 9),
  - Einhaltung von Logging-, Stats-, Berechtigungs- und Sentinel-Regeln.

3.4 Icons & Assets
------------------
- Icons/Logos im Repo:
  - `assets/icons/...`
- Bot-Discord:
  - Custom-Emoji & Attachments.
- Zentrale Definition:
  - `src/bot/general/icons/icons.json`
    - z. B.:

      {
        "poll":   { "typ": "emoji",   "wert": "<:meat_poll:123456789012345678>" },
        "stats":  { "typ": "emoji",   "wert": "<:meat_stats:234567890123456789>" },
        "fehler": { "typ": "unicode", "wert": "‚ö†Ô∏è" }
      }

- Funktionen nutzen nur Icon-Keys (`"poll"`, `"stats"`, `"fehler"`), nicht direkt IDs.
- Jede Funktion soll ‚Äì wo sinnvoll ‚Äì ein eigenes Modul-Icon und passende Farben aus `module-styles.ts` verwenden, um ein konsistentes MEAT-Branding zu erreichen.

3.5 Logs-Verzeichnis
--------------------
- Logs liegen unter:
  - `logs/<funktion>/<funktion>-YYYY-MM-DD.log`

==================================================
4. INTERAKTIONS- & UX-REGELN
==================================================

4.1 Slash-Command + Buttons als Standard
----------------------------------------
- Einstieg √ºber Slash-Commands (z. B. `/poll`, `/stats`, `/user`).
- Weitere Interaktionen:
  - Buttons (Weiter, Zur√ºck, Abbrechen, etc.),
  - Modals f√ºr Eingaben,
  - ggf. Select-Men√ºs.
- Ziel:
  - Wenige Commands, viele Interaktionen per Buttons/Modals.

4.2 Embed-first
---------------
- Antworten standardm√§√üig als Embeds, nicht Plaintext.
- Embeds werden √ºber:
  - `create-standard-embed.ts` (globaler Builder),
  - optionale funktionsspezifische Helper (`<funktion>.embeds.ts`),
  aufgebaut.
- Funktions-Embeds sollen auf dem Standard-Embed-Builder aufsetzen (Header, Farben, Icons etc.).

- Jede Funktion soll ‚Äì wo sinnvoll ‚Äì ihr Modul-Icon und die Modul-Farbe aus `module-styles.ts` nutzen, damit:
  - Embeds visuell dem jeweiligen Modul zugeordnet werden k√∂nnen,
  - das Gesamterscheinungsbild einheitlich bleibt.

4.3 Ephemeral vs. √∂ffentlich
----------------------------
- Tendenz:
  - User-spezifisch ‚Üí eher ephemeral,
  - Community-relevant (Poll-Start, Ergebnisse, Events) ‚Üí √∂ffentlich.
- Wichtig:
  - Bei Planung jeder Funktion wird explizit festgelegt:
    - welche Antworten ephemeral sind,
    - welche √∂ffentlich sind.
- Standard kann ‚Äûephemeral‚Äú sein, wird aber pro Funktion/Use-Case bewusst geplant.

4.4 Fehler & Best√§tigungen
--------------------------
- Fehler:
  - kurze, sachliche Texte aus `texte.de.json` (Bereich `fehler`).
- Best√§tigungen:
  - kurz, gern mit MEAT-Humor, aber verst√§ndlich.
- Kritische Meldungen (Rollen, Rechte, Sicherheit, Datenschutz):
  - n√ºchterner Ton.

4.5 Assistenten-Flows (‚ÄûSeiten‚Äú)
--------------------------------
- Komplexe Funktionen k√∂nnen als Wizard laufen:
  - mehrere Seiten/Schritte:
    - z. B. `start`, `auswahl`, `bestaetigung`, `ergebnis`.
- Texte in `texte.<sprache>.json`, Bereich `seiten`, z. B.:
  - `seiten.start`, `seiten.spieleAuswahl`, `seiten.bestaetigung` etc.
- Navigation:
  - Button-IDs (z. B. `poll_start`, `poll_weiter_spiele`, `poll_zurueck_start`),
  - ggf. Statusverwaltung (z. B. Poll-ID, Schritt).

4.6 Buttons & Modals
--------------------
- Button-Texte:
  - aus `texte.<sprache>.json` (z. B. Bereiche `buttons`, `buttonsGlobal` oder `seiten.<name>.buttons`).
- Icons:
  - √ºber `icons.json` / `icon-registry`.
- Button-ID-Schema (Grundsatz):
  - `funktion_aktion[_zusatz]`
    - z. B. `poll_start`, `poll_weiter_spiele`, `poll_abbrechen`.
  - Kann um IDs erweitert werden:
    - z. B. `poll_vote_<pollId>_<gameId>`.

- Modals:
  - Titel, Feld-Labels, Placeholder:
    - in `modals`-Bereich der Texte.
  - IDs:
    - analog: `funktion_modal_<zweck>`.

4.7 Aufbau eines `<funktion>.command.ts`
----------------------------------------
Typischer Aufbau:

1. Imports (Discord, Logger, Text-Loader, Icons, Styles, Services).
2. Texte laden (`ladeTexte("funktion", sprache)`).
3. Slash-Command-Definition (Name, Beschreibung, Optionen).
4. Handler:
   - Berechtigungen pr√ºfen,
   - Server-/User-Settings laden,
   - Stats/Logging-Start,
   - Service-Logik ausf√ºhren,
   - Embed & Antwort bauen.
5. Ergebnis/Fehler loggen.

4.8 Stil & Persona
------------------
- Normal:
  - leicht frech / trashig, MEAT-typischer Humor.
- Kritisch:
  - neutral, kurz, sachlich.
- Footer:
  - optional, kein Pflichtwitz.

==================================================
4a. SPEZIALFALL FUNKTION `ai`
==================================================

4a.1 Ziel
---------
- Die Funktion `ai` ist die Chat-/KI-Komponente von MEAT:
  - reagiert auf Erw√§hnungen wie `@MEAT`,
  - kann Slash-Commands f√ºr strukturierte Nutzung bereitstellen (z. B. `/ai`, `/ai hilfe`),
  - soll sich im Chat wie ein ‚Äûnormaler User‚Äú anf√ºhlen.

4a.2 Ausnahme von Embed-Regel
------------------------------
- Grundsatz (4.2): Embed-first.
- Ausnahme f√ºr `ai`:
  - Bei direkter Erw√§hnung im Text (z. B. ein User schreibt `@MEAT ...` in einen normalen Channel):
    - antwortet `ai` standardm√§√üig mit **Plaintext**, NICHT im Embed,
    - die Antwort soll wie eine normale User-Nachricht wirken.
  - Embeds d√ºrfen bei `ai` verwendet werden, wenn:
    - Listen, √úbersichten, Befehlshilfen dargestellt werden (z. B. `/ai hilfe`, Modus-Auswahl),
    - Einstellungen gezeigt/verwaltet werden.

4a.3 Erw√§hnungen & Reaktionen
-----------------------------
- Wenn ein User `@MEAT` schreibt:
  - `ai` pr√ºft:
    - ist Funktion `ai` auf diesem Server aktiv?
    - (sp√§ter) sind KI-/GPT-Funktionen intern erlaubt?
  - Bei Erlaubnis:
    - Antwort als normale Nachricht (Plaintext),
    - optional Reaktionen (Emojis) auf die User-Nachricht, z. B. üëç, ü§î, üòè, je nach Kontext.

4a.4 Slash-Commands f√ºr `ai`
----------------------------
- Wenn `ai` Slash-Commands bereitstellt (z. B. `/ai`, `/ai frage`, `/ai hilfe`):
  - gelten die allgemeinen Regeln:
    - Embed-first,
    - bewusste Planung von ephemeral vs. √∂ffentlich,
    - Logging/Stats wie bei anderen Funktionen.
  - Plaintext kann zus√§tzlich genutzt werden, wenn sinnvoll.

4a.5 Datenschutz & Logging (High-Level)
---------------------------------------
- Inhalte, die √ºber `ai` verarbeitet werden, gelten als sensibel.
- Logging:
  - vollst√§ndige User-Nachrichten nach M√∂glichkeit nicht oder nur minimiert loggen (z. B. gek√ºrzt/anonymisiert),
  - Fokus auf Metadaten (wo, wann, welche Funktion) statt Volltext.
- Personenbezogene Stats:
  - z. B. ‚Äûwie oft nutzt User X `ai`‚Äú nur bei Opt-in (Abschnitt 6 & 7).

4a.6 KI-Agent, Tools & Live-Discord-Kontext
-------------------------------------------
- `ai` nutzt intern einen KI-Agenten (z. B. √ºber das OpenAI Agents SDK / Agent Builder). Der eigentliche ‚ÄûGehirn-Teil‚Äú liegt im Modul `ai`, w√§hrend der Rest des Bots (Commands, Buttons, Polls usw.) wie gewohnt √ºber andere Funktionsordner l√§uft.
- In den Instructions des KI-Agents wird dieses MASTER-RULESET als Grundlage festgelegt; `ai` respektiert alle Modul-Grenzen, Sentinel-/Datenschutz-Regeln und Settings.
- Der Agent darf **Tools** verwenden, die unter `src/bot/functions/ai/tools/` liegen. Typische Tools:
  - `discord-tools` (z. B. ‚Äûgib mir alle Channels & Events dieser Guild‚Äú),
  - `user-preferences` (z. B. ‚Äûwie soll ich diesen User ansprechen?‚Äú),
  - weitere projektinterne Tools (Polls, Vault, Events, Stats).
- Live-Daten aus Discord und aus der eigenen Datenbank werden **nicht** als statische Dateien hochgeladen, sondern √ºber diese Tools gelesen. Damit ist das Wissen des Agents √ºber:
  - Channels,
  - Events,
  - Rollen,
  - interne Konfigurationen (z. B. Montagspoll, HottLAN-Events),
  immer aktuell.
- Der Agent soll bei Fragen zur aktuellen Server-Struktur **immer zuerst Tools nutzen**, statt sich Dinge auszudenken.

4a.7 Sessions & Kurzzeit-Ged√§chtnis
-----------------------------------
- Unterhaltungen mit `ai` laufen √ºber **Sessions**: eine Session b√ºndelt die Nachrichten-Historie eines Gespr√§chs.
- Die Session-ID darf z. B. aus `guildId:userId` oder `guildId:channelId:userId` bestehen. Ziel:
  - zusammengeh√∂rige Unterhaltungen bleiben f√ºr die KI verst√§ndlich,
  - aber verschiedene Kontexte (DM vs. √∂ffentlich, anderer Server) werden getrennt behandelt.
- Das Session-Ged√§chtnis ist **kurzfristig**:
  - es speichert nur den Verlauf f√ºr dieses Gespr√§ch und wird technisch bei Bedarf zusammengefasst/gek√ºrzt,
  - es ersetzt **nicht** die dauerhafte Speicherung von Einstellungen, sondern erg√§nzt sie nur.
- Gesch√§ftskritische Einstellungen oder ‚ÄûRegeln‚Äú f√ºr den Bot h√§ngen **nie nur** am Session-Kontext, sondern werden immer in Settings/DB abgelegt.

4a.8 Dauerhafte Pr√§ferenzen & ‚ÄûNenn mich XY‚Äú-F√§lle
--------------------------------------------------
- Dauerhafte Vorlieben einzelner User (z. B. ‚ÄûNenn mich bitte Hiro statt Herr Kr√§mer‚Äú) werden nicht allein dem Modell √ºberlassen, sondern explizit gespeichert.
- Daf√ºr gibt es Tools im `ai`-Modul, z. B.:
  - `set_preferred_name` ‚Üí speichert den gew√ºnschten Rufnamen eines Users,
  - `get_user_profile` ‚Üí liest gespeicherte Pr√§ferenzen (z. B. Rufname) aus.
- Speicherort f√ºr solche Pr√§ferenzen:
  - bevorzugt in der Datenbank (z. B. Prisma-Modell `UserPreference`),
  - alternativ oder erg√§nzend unter `userSettings.pr√§ferenzen.user.preferredName`.
- Wenn ein User der KI sagt, wie er genannt werden m√∂chte, gilt die Regel:
  - `ai` ruft ein entsprechendes Tool auf (z. B. `set_preferred_name`) und speichert die Info,
  - sp√§tere Antworten d√ºrfen √ºber `get_user_profile` den Namen auslesen und verwenden.
- Diese Informationen gelten als **personenbezogene Daten**. Sie werden nur genutzt, wenn:
  - `serverSettings.datenschutz.userTrackingErlaubt = true` **und**
  - `userSettings.datenschutz.trackingErlaubt = true`.
- Beim Widerruf des Opt-ins (oder bei expliziter L√∂schung durch den User) m√ºssen gespeicherte Pr√§ferenzen gel√∂scht oder inaktiviert werden; `ai` darf sie dann nicht mehr verwenden.

==================================================
5. LOGGING
==================================================

5.1 Ziele
---------
- Nachvollziehbarkeit:
  - wer,
  - wann,
  - was,
  - mit welchem Ergebnis.
- Grundlage f√ºr:
  - Debugging,
  - Monitoring,
  - Statistiken.

5.2 Zentraler Logger
--------------------
- `src/bot/general/logging/logger.ts`
- Bietet Funktionen, z. B.:

  - `protokolliereInfo(funktion, aktion, nachricht, kontext?)`
  - `protokolliereWarnung(...)`
  - `protokolliereFehler(...)`
  - `protokolliereDebug(...)`

- Keine direkten `console.log` im Produktivcode.

5.3 Levels
----------
- `debug`
- `info`
- `warn`
- `error`

5.4 `log.config.ts` pro Funktion
--------------------------------
- Jede Funktion besitzt `log.config.ts`, z. B.:

  - `aktiv: boolean`
  - `bereiche: { aufrufe: boolean; fehler: boolean; performance: boolean; ... }`
  - `ausgabe: { konsole: boolean; datei: boolean; discord: boolean }`
  - `dateiName: string`
  - optional `discordKanalEinstellungsKey: string` (Key in ServerSettings, z. B. `pollLogChannelId`)

5.5 Server-Settings & Logging
-----------------------------
- Relevante Keys in `serverSettings.functions.<funktion>`:
  - `loggingAktiv`
  - `logLevel`
  - `logChannelId?`

5.6 Log-Dateien
---------------
- Speicherort:
  - `logs/<funktion>/<funktion>-YYYY-MM-DD.log`

5.7 Log-Inhalt
--------------
- Mindestens:
  - Zeitstempel,
  - Level,
  - Funktion,
  - Aktion (z. B. `commandStart`, `buttonClick`, `error`),
  - Kontext (guildId, channelId, userId, ggf. Funktions-IDs),
  - optional Dauer.

5.8 Wann loggen?
----------------
- Mindestens:
  - Command-Start/-Ende,
  - relevante Button-/Modal-Aktionen,
  - Fehler mit Kontext.
- Optional:
  - Performance,
  - Debug-Informationen.

5.9 DEV vs PROD
---------------
- DEV:
  - `debug` erlaubt,
  - ausf√ºhrliche Logs.
- PROD:
  - mindestens `info`,
  - `debug` meist aus,
  - keine sensiblen Inhalte (Tokens, Passw√∂rter, DM-Inhalte).

==================================================
6. STATISTIKEN & TRACKING
==================================================

6.1 Grundsatz & Datenschutz
---------------------------
- Stats sind von Anfang an eingeplant.
- Zwei Ebenen:
  - Aggregierte Stats (ohne Personenbezug) ‚Üí immer okay.
  - Personenbezogene Stats (mit User-ID) ‚Üí nur mit Opt-in.

6.2 Zentrale Stats-Infrastruktur
--------------------------------
- `src/bot/general/stats/`:
  - `stats-manager.ts`
  - `stats-typen.ts`
- Funktionen melden Stats ausschlie√ülich √ºber `stats-manager`, NICHT direkt in DB/Files.

6.3 `stats.config.ts` pro Funktion (optional, empfohlen)
--------------------------------------------------------
- Definiert pro Funktion:
  - welche Ereignisse getrackt werden (Aufrufe, Buttons, besondere Outcomes),
  - ob personenbezogene Stats vorgesehen sind (`trackUserbezogen: boolean`),
  - Details zu gespeicherten Feldern.

6.4 Aggregierte Stats
---------------------
- Beispiele:
  - Aufrufe pro Funktion / Tag / Woche / Guild,
  - Button-Nutzung (z. B. wie oft ‚ÄûWeiter‚Äú, ‚ÄûAbbrechen‚Äú),
  - Drop-offs in Wizards (welcher Schritt wird oft verlassen),
  - Ergebnisverteilungen (z. B. Polls),
  - Performance (Durchschnittsdauer, Fehlerquote).

6.5 Personenbezogene Stats (Opt-in)
-----------------------------------
- Nur wenn:
  - Server Tracking erlaubt: `serverSettings.datenschutz.userTrackingErlaubt = true`,
  - User zugestimmt hat: `userSettings.datenschutz.trackingErlaubt = true`.
- Beispiele:
  - wie oft ein User eine Funktion nutzt,
  - letzte Nutzung,
  - bevorzugte Modi/Optionen,
  - Gamification (Achievements, R√§nge).
- Sensible Freitextinhalte werden nicht einfach als personenbezogene Stats gespeichert.

6.6 Opt-in / Opt-out
--------------------
- Gesteuert √ºber Sentinel-Datenschutz (Abschnitt 7).
- Vor jeder personenbasierten Speicherung pr√ºft `stats-manager`:
  - Server erlaubt Tracking?
  - User hat Opt-in?

6.7 Stats vs Logs
-----------------
- Logs:
  - detailreich, technisch, eher kurzlebig.
- Stats:
  - aggregiert, datensparsam, langlebig.
- Stats k√∂nnen direkt geschrieben oder aus Logs aggregiert werden.

6.8 Meta-Stats (Funktionen & Commands)
--------------------------------------
- Zentral werden gez√§hlt:
  - wie viele Funktionen (Ordner unter `src/bot/functions/`) existieren,
  - wie viele Commands registriert sind.
- Diese Meta-Stats k√∂nnen sp√§ter √ºber `/stats bot` oder im Web angezeigt werden.

==================================================
7. SENTINEL ‚Äì DATENSCHUTZ, SICHERHEIT, SPAM & RAID
==================================================

7.1 Sentinel-Bereich
--------------------
- Alles zu Datenschutz & Sicherheit liegt unter:

  - `src/bot/functions/sentinel/`

- Geplante/definierte Unterbereiche:

  - `sentinel/datenschutz/` ‚Üí Opt-in/Opt-out, Datenschutz-√úbersicht.
  - `sentinel/spam/`        ‚Üí Anti-Spam-Mechanismen (geplant).
  - `sentinel/warnungen/`   ‚Üí Warnsystem/Mutes/Bans (geplant).
  - `sentinel/raid/`        ‚Üí Raid-Erkennung & Verteidigung (geplant).
  - `sentinel/monitoring/`  ‚Üí System-Monitoring & Auslastung (geplant).

7.2 Funktion `sentinel/datenschutz`
-----------------------------------
- Aufgaben:
  - Verwaltung der Einwilligung zu personenbezogenem Tracking (Opt-in/Opt-out),
  - Anzeige, was getrackt wird,
  - Pflege von `userSettings.datenschutz.trackingErlaubt`.
- M√∂gliche Wege:
  - Willkommensnachricht mit Buttons ‚ÄûJa‚Äú / ‚ÄûNein‚Äú,
  - eigener Command (z. B. `/datenschutz`),
  - DM-Flows f√ºr bestehende User.
- Dateien:
  - `datenschutz.command.ts`
  - `datenschutz.buttons.ts`
  - `datenschutz.embeds.ts`
  - `log.config.ts`
  - `texte.de.json`
  - optional `stats.config.ts`.

7.3 Spam-Funktion & Warnsystem (geplant)
----------------------------------------
- `sentinel/spam/`:
  - Erkennung von Spam (z. B. viele Nachrichten in kurzer Zeit, bestimmte Muster).
- `sentinel/warnungen/`:
  - Verwarnungssystem,
  - Historie pro User,
  - Eskalationen (Mute/Kick/Ban), abh√§ngig von Server-Policies.
- Basisregeln:
  - Texte in JSON,
  - Logging via `log.config.ts`,
  - Stats optional,
  - personenbezogene Stats nur bei Opt-in.

7.4 Raid-Verteidigung (geplant)
-------------------------------
- `sentinel/raid/`:
  - Erkennung von Raid-Mustern (Join-Spikes, Spam-Wellen),
  - ‚ÄûRaid-Modus‚Äú:
    - neue Joins begrenzen/verz√∂gern,
    - Nachrichten einschr√§nken,
    - Admins informieren.

7.5 Sentinel-Monitoring (√úberblick)
-----------------------------------
- Details zu `sentinel/monitoring` siehe Abschnitt 18.
- Kurz:
  - √ºberwacht Nutzung, Fehlerquote, Performance,
  - hilft, √úberlastung oder ungew√∂hnliches Verhalten zu erkennen.

==================================================
8. SERVER- & USER-SETTINGS
==================================================

8.1 Ziele
---------
- Konfigurierbare Dinge werden nicht hart im Code verdrahtet, sondern:
  - pro Guild in `serverSettings`,
  - pro User in `userSettings`,
  - global in `globaleEinstellungen`.
- Funktionen greifen nur √ºber zentrale Loader/Helper auf Settings zu, nicht direkt auf DB/JSON.

8.2 Speicherort & Zugriff
-------------------------
- Typen & Helper:

  src/bot/general/config/server-settings-schema.ts
  src/bot/general/config/server-settings-loader.ts
  src/bot/general/config/user-settings-schema.ts
  src/bot/general/config/user-settings-loader.ts
  src/bot/general/config/global-settings-schema.ts
  src/bot/general/config/global-settings-loader.ts

8.3 ServerEinstellungen (logisch)
---------------------------------
- Enth√§lt u. a.:

  - `guildId: string`
  - `sprache: 'de' | 'en'` (Standard-Sprache f√ºr Texte)
  - `datenschutz`:
    - `userTrackingErlaubt: boolean` (darf der Server personenbezogene Stats √ºberhaupt erlauben?)
    - ggf. `hinweisAngezeigt?: boolean`
  - `functions: { [funktionsName: string]: FunktionEinstellungen }` mit z. B.:
    - `aktiv: boolean` (Funktion auf dieser Guild aktiv/deaktiv)
    - `loggingAktiv: boolean`
    - `logLevel: 'debug' | 'info' | 'warn' | 'error'`
    - `logChannelId?: string`
    - `statsAktiv: boolean`
    - `ephemeralStandard?: boolean`
    - `erlaubteRollenIds?: string[]`
    - `spezifisch?: Record<string, unknown>` (funktion-spezifische Settings)
  - `sentinel`:
    - `spamSchutzAktiv: boolean`
    - `raidSchutzAktiv: boolean`
    - `warnSystemAktiv: boolean`
    - optionale Detail-Bl√∂cke:
      - `spam?: Record<string, unknown>`
      - `raid?: Record<string, unknown>`
      - `warnungen?: Record<string, unknown>`

- Der Wert `functions.<funktion>.aktiv` ist die zentrale Schaltstelle:
  - er wird sowohl im Bot (Commands) als auch im Web-Dashboard angezeigt,
  - √Ñnderungen k√∂nnen √ºber Commands oder √ºber das Web-Dashboard vorgenommen werden.

8.4 UserEinstellungen (logisch)
-------------------------------
- Enth√§lt u. a.:

  - `userId: string`
  - `sprache?: 'de' | 'en'` (User-spezifische Sprache, optional)
  - `datenschutz`:
    - `trackingErlaubt: boolean` (Opt-in/Opt-out)
    - `letzteEntscheidungAm?: string` (ISO-String)
  - `pr√§ferenzen?: { [funktionsName: string]: Record<string, unknown> }`
    - z. B. `pr√§ferenzen.reminder`, `pr√§ferenzen.user`, `pr√§ferenzen.ranks`
  - (logisch vorgesehen) weitere Bereiche:
    - z. B. `connect`-/`stream`-bezogene Daten (verkn√ºpfte Accounts, siehe Abschnitt 10),
    - Reminder-/Geburtstags-Einstellungen (siehe Abschnitt 14).

8.5 Loader
----------
- `ladeServerEinstellungen(guildId)` / `speichereServerEinstellungen(...)` / `aktualisiereServerEinstellungen(...)`
- `ladeUserEinstellungen(userId)` / `speichereUserEinstellungen(...)` / `aktualisiereUserEinstellungen(...)`
- `ladeGlobaleEinstellungen()` / `speichereGlobaleEinstellungen(...)`

8.6 Zusammenspiel Funktionen ‚Üî Settings
---------------------------------------
- Jede Funktion:
  - l√§dt zun√§chst `serverSettings` f√ºr die Guild,
  - liest relevante Werte unter `functions.<funktion>` und `sentinel`,
  - l√§dt bei Bedarf `userSettings`,
  - trifft darauf basierend Entscheidungen:
    - Funktion aktiv ja/nein (`aktiv`),
    - Logging/Stats ja/nein,
    - Ephemeral-Standard,
    - Berechtigungen.

8.7 Defaults (Empfohlen)
------------------------
- Server:
  - `sprache = 'de'`
  - `datenschutz.userTrackingErlaubt = true`
- User:
  - `sprache`: nicht gesetzt ‚Üí Fallback auf Server-Sprache,
  - `datenschutz.trackingErlaubt = false` (kein personenbezogenes Tracking, bis Opt-in erfolgt).
- Sentinel:
  - `spamSchutzAktiv`, `raidSchutzAktiv`, `warnSystemAktiv` starten als `false` und werden √ºber Commands/Settings aktiviert.

8.8 Globale Bot-Einstellungen & Guild-Whitelist
-----------------------------------------------
- `GlobaleEinstellungen` enthalten u. a.:
  - `invitePolicy: 'whitelist' | 'blacklist' | 'open'`
  - `erlaubteGuildIds: string[]`
  - `geblockteGuildIds: string[]`
  - `globalAdmins: string[]` (Discord-User-IDs, die im Web & Bot ‚Äûalles sehen‚Äú d√ºrfen)
- Empfohlene Standard-Policy:
  - `invitePolicy = 'whitelist'`
- Wenn der Bot in eine **nicht erlaubte** Guild eingeladen wird:
  1. Alle Funktionen auf dieser Guild werden sofort deaktiviert (Bot verh√§lt sich passiv).
  2. Owner/Admins der Guild erhalten eine Info-Nachricht:
     - Erkl√§rung, warum der Bot hier nicht aktiv ist,
     - Einladungslink zum offiziellen MEAT-/Bot-Discord, um Freigabe zu kl√§ren.
  3. Danach verl√§sst der Bot automatisch diese Guild (Leave Guild).

==================================================
9. FUNKTIONS-PLANUNGS-CHECKLISTE (PFLICHT)
==================================================

9.1 Ziel
--------
- Bevor eine neue Funktion in `src/bot/functions/<funktion>/` implementiert wird, gibt es IMMER einen kurzen Plan.
- Der Plan beantwortet zentrale Fragen zu:
  - Flow,
  - Interaktionen,
  - Text-Struktur,
  - Logging,
  - Stats,
  - Berechtigungen,
  - Settings,
  - Sentinel-/Datenschutz-Auswirkungen.

9.2 Checkliste (Fragen & Punkte)
--------------------------------

1. Name & Zweck
   - Wie hei√üt die Funktion (Ordnername)?
   - Kurzbeschreibung: Was soll sie tun?

2. Commands
   - Welche Slash-Commands gibt es?
     - z. B. `/poll`, `/poll montag`, `/stats server`, `/stream connect`.
   - Gibt es Subcommands?
     - z. B. `/poll start`, `/poll ergebnis`, `/poll close`.

3. Flow / Assistent / Seiten
   - Ist es ein einmaliger Command oder ein Wizard/Assistent?
   - Falls Wizard:
     - welche Seiten/Schritte (start, auswahl, zusammenfassung, bestaetigung, ergebnis, ...),
     - welche √úberg√§nge (Buttons ‚Üí Seitenwechsel).

4. Interaktionen
   - Welche Buttons?
     - Aktionen pro Seite (Weiter, Zur√ºck, Abbrechen, etc.),
     - globale Buttons (Hilfe, Ergebnis anzeigen).
   - Welche Modals?
     - Felder (Label, Placeholder, Typ).
   - Weitere Komponenten?
     - z. B. Select-Men√ºs.

5. Texte & JSON-Struktur
   - Welche Texte werden ben√∂tigt?
     - Command-Namen & Beschreibungen,
     - Embed-Titel & -Texte,
     - Button-Texte,
     - Modal-Titel, Feldlabels, Placeholder,
     - Fehlermeldungen,
     - Erfolgsmeldungen.
   - Wie werden Keys in `texte.de.json` strukturiert?
     - z. B. `command`, `seiten`, `buttonsGlobal`, `modals`, `fehler`.

6. Ephemeral vs. √∂ffentlich
   - Welche Antworten sind ephemeral?
   - Welche sind √∂ffentlich?
   - Gibt es Admin-only-Infos (z. B. Systemstatus), die nicht jeder sehen darf?

7. Logging
   - Was wird geloggt?
     - Command-Start/-Ende,
     - Button-/Modal-Aktionen,
     - Fehler,
     - Performance.
   - Gibt es spezielle Zusatzinfos im Log (z. B. Poll-ID, Event-ID, User-/Guild-Kontext)?

8. Stats
   - Welche aggregierten Stats sind sinnvoll?
   - Sollen personenbezogene Stats erhoben werden?
     - Welche?
     - IMMER unter Beachtung:
       - `serverSettings.datenschutz.userTrackingErlaubt`
       - `userSettings.datenschutz.trackingErlaubt`.
   - Braucht die Funktion ein `stats.config.ts`?

9. Berechtigungen
   - Wer darf die Funktion nutzen?
     - alle / bestimmte Rollen / nur Admin/Owner?
   - Wie werden Rollen gepflegt?
     - z. B. `serverSettings.functions.<funktion>.erlaubteRollenIds`,
     - ggf. `serverSettings.berechtigungen` (siehe Abschnitt 16).

10. Server- & User-Settings
    - Braucht die Funktion eigene Settings?
      - z. B. `aktiv`, `loggingAktiv`, `ephemeralStandard`, spezielle Parameter.
    - Sollen Defaults definiert werden?
    - Nutzt die Funktion User-Pr√§ferenzen (z. B. Darstellung, Sprache, Modus)?

11. Icons & Darstellung
    - Welches Icon (Key in `icons.json`) geh√∂rt zur Funktion?
    - Gibt es eigene Modul-Farben/Styles (Eintrag in `module-styles.ts`)?
    - Werden Bilder/Thumbnails verwendet?

12. Sicherheit & Sentinel
    - Ber√ºhrt die Funktion:
      - Datenschutz (personenbezogene Daten),
      - Moderation (Warnungen/Bans),
      - Spam/Raid-Erkennung,
      - System-Monitoring?
    - Wenn ja:
      - wie interagiert sie mit Sentinel-Modulen?
      - welche Mindest-Schutzma√ünahmen sind Pflicht?

9.3 Ergebnis der Planung
------------------------
- Pro Funktion existiert eine kurze Plan-Notiz, z. B.:

  - `docs/plans/<funktion>-plan.md`

- Inhalt:
  - Kurzbeschreibung,
  - Stichpunkte zu den 12 Checklisten-Punkten,
  - optional Flow-Skizzen.
- ChatGPT nutzt diese Plan-Dateien sp√§ter, um Code zu generieren, der zur geplanten Struktur passt.

==================================================
10. STREAM- & ACCOUNT-CONNECT
==================================================

10.1 Ziel
---------
- Die Module `connect` und `stream` bauen die Basis f√ºr:
  - das Verkn√ºpfen von Discord-Usern mit externen Accounts (Twitch, YouTube, Steam, League, ‚Ä¶),
  - das Ausl√∂sen von Ank√ºndigungen (z. B. ‚ÄûUser X geht live‚Äú, ‚Äûneues Video online‚Äú),
  - sp√§tere Nutzung der Verkn√ºpfungen im Web-Dashboard oder durch einen separaten `stream-bot`.

10.2 Ort im Projekt
-------------------
- `connect` (Kern-Verkn√ºpfungen):

  - `src/bot/functions/connect/`
    - `connect.command.ts` (z. B. `/connect twitch`, `/connect youtube`, `/connect steam`)
    - `connect.buttons.ts`
    - `connect.modals.ts`
    - `connect.embeds.ts`
    - `connect.service.ts`
    - `log.config.ts`
    - `stats.config.ts` (optional)
    - `texte.de.json`

- `stream` (Ank√ºndigungs-Logik):

  - `src/bot/functions/stream/`
    - `stream.command.ts` (z. B. `/stream settings`, `/stream test`)
    - `stream.buttons.ts`
    - `stream.embeds.ts`
    - `stream.service.ts`
    - `log.config.ts`
    - `stats.config.ts` (optional)
    - `texte.de.json`

10.3 Datenschutz-Pflicht f√ºr CONNECT
------------------------------------
- Vor jedem CONNECT-Vorgang (z. B. `/connect twitch`):
  - pr√ºfen:
    - `serverSettings.datenschutz.userTrackingErlaubt`,
    - `userSettings.datenschutz.trackingErlaubt`.
- Wenn eine Bedingung nicht erf√ºllt:
  - CONNECT wird verweigert,
  - User bekommt eine kurze, sachliche Info (ephemeral), z. B. Hinweis auf `/datenschutz`.

10.4 Datenmodell im User-Settings-Bereich (logisch)
---------------------------------------------------
- Logisch vorgesehen (Details folgen in TS-Typen):

  - `userSettings.connect.accounts: AccountVerknuepfung[]`, z. B.:
    - `plattform: 'twitch' | 'youtube' | 'steam' | 'league' | ...`
    - `externeId: string` (z. B. Channel-ID, Steam-ID, Summoner-ID)
    - `kanalName: string`
    - `oeffentlichAnzeigen: boolean`
    - `letzteAktualisierungAm?: string`

- Diese Daten sind personenbezogen:
  - nur mit Opt-in,
  - Opt-out/L√∂schung muss sp√§ter sauber m√∂glich sein.

10.5 Server-Settings f√ºr Stream-Ank√ºndigungen (logisch)
-------------------------------------------------------
- √úber `serverSettings.functions.stream.spezifisch`:

  - `ankuendigungenAktiv: boolean`
  - `standardAnkuendigungsChannelId?: string`
  - `ankuendigeLivestreams: boolean`
  - `ankuendigeUploads: boolean`

- Sp√§ter erweiterbar:
  - z. B. Filter pro Plattform/User.

10.6 Nutzung durch Web & Stream-Bot
-----------------------------------
- `connect` stellt zentrale Verkn√ºpfungsdaten bereit.
- `stream` nutzt diese Daten, um Ank√ºndigungen im Discord zu posten.
- Web-Dashboard und/oder `stream-bot` k√∂nnen dieselben Daten verwenden:
  - Web:
    - um anzuzeigen, welche Accounts pro User/Guild verbunden sind,
    - um pro Guild/Streamer zu konfigurieren, welche Features aktiv sind (z. B. Live-Ank√ºndigungen, Upload-Posts, Clips).
  - `stream-bot`:
    - liest Einstellungen und Verkn√ºpfungen grunds√§tzlich nur aus (read-only),
    - darf nur dort schreibend agieren, wo es sinnvoll ist (z. B. Chat-Commands im Streaming-Chat, Posten von Ank√ºndigungen).

10.7 Opt-out & L√∂schung
-----------------------
- Bei Wechsel von `trackingErlaubt: true ‚Üí false`:
  - personenbezogene Nutzung der Verkn√ºpfungen muss enden,
  - verkn√ºpfte Konten sollen entfernt oder anonymisiert werden.
- Server-seitige Deaktivierung (`userTrackingErlaubt = false`) schr√§nkt die Nutzung der Daten serverbezogen ein.

10.8 Logging & Stats f√ºr Stream/Connect
---------------------------------------
- Logging:
  - CONNECT-/DISCONNECT-Aktionen,
  - √Ñnderungen von Ank√ºndigungs-Settings,
  - fehlgeschlagene API-Abfragen (ohne sensible Daten).
- Stats:
  - aggregiert:
    - wie viele User haben Accounts verkn√ºpft,
    - wie viele Ank√ºndigungen wurden verschickt.
  - personenbezogen:
    - nur mit Opt-in.

10.9 Zentrales `connect`-Modul
------------------------------
- `connect` kapselt:
  - alle Logiken zur Verkn√ºpfung von Discord-Usern mit externen Accounts.
- Andere Module (`stream`, `league`, `steam`, `user`, `ranks`, Web) nutzen diese Daten lesend.

==================================================
11. FUNKTION `user` (GEPLANT)
==================================================

11.1 Ziel
---------
- `user` bietet sp√§ter:
  - ein MEAT-User-Profil,
  - Anzeige von Stats (sofern Opt-in),
  - Personalisierung (z. B. bevorzugte Sprache, Darstellungsoptionen).

11.2 M√∂gliche Features
----------------------
- `/user profil`:
  - MEAT-Profil des Users:
    - Nickname, Avatar, evtl. verbundene Accounts (wenn freigegeben),
    - Zusammenfassung wichtiger Stats (z. B. Poll-Teilnahmen, Spielaktivit√§t),
    - R√§nge/Badges aus `ranks`,
    - optionale externe Infos (z. B. League-Rank, Steam-Highlights, falls via `connect` verkn√ºpft und freigegeben).
- `/user einstellungen`:
  - Sprache,
  - Datenschutz-Shortcuts (Verweis auf `sentinel/datenschutz`),
  - Anzeige-Optionen (z. B. ‚Äûzeige meine Stats √∂ffentlich / nur mir‚Äú).

- Umsetzung erfolgt sp√§ter nach der Funktions-Planungs-Checkliste.
- Im Web-Dashboard soll ein eingeloggter User sein Profil, Achievements und Stat-Auswertungen ebenfalls in einer eigenen Ansicht sehen k√∂nnen (siehe Abschnitt 20).

==================================================
12. FUNKTION `randomizer` (GEPLANT)
==================================================

12.1 Ziel
---------
- `randomizer` b√ºndelt alle Zufalls-Features:
  - W√ºrfelw√ºrfe,
  - Coinflip,
  - zuf√§llige LoL-Champions,
  - Team-Zuordnungen,
  - weitere Random-Funktionen.

12.2 M√∂gliche Features
----------------------
- `/randomizer roll` ‚Üí W√ºrfel (`XdY`-Notation).
- `/randomizer coinflip` ‚Üí Kopf oder Zahl.
- `/randomizer lol`:
  - zuf√§llige Champions basierend auf:
    - Teamgr√∂√üe,
    - Rollen (Top/Jungle/Mid/ADC/Support),
    - Spielmodus (ARAM, URF, Normal, Ranked).
- `/randomizer team`:
  - zuf√§llige Teams aus einer Liste von Spielern.

12.3 UX & Darstellung
---------------------
- Ergebnisse vorzugsweise in kompakten Embeds:
  - klar hervorgehobenes Ergebnis,
  - optional kleine Gags im MEAT-Stil.
- Ephemeral vs. √∂ffentlich:
  - Party-/Fun-Anwendungen ‚Üí eher √∂ffentlich,
  - pers√∂nliche Rolls ‚Üí optional ephemeral.

12.4 Logging & Stats
--------------------
- Logging:
  - Nutzung der einzelnen Subfeatures (roll, coinflip, lol, team).
- Stats:
  - aggregiert:
    - welche Random-Funktionen am beliebtesten sind,
    - wie oft pro Server/Tag/Woche.

==================================================
13. FUNKTION `events` (GEPLANT)
==================================================

13.1 Ziel
---------
- `events` verwaltet native Discord-Events:
  - Erstellen,
  - Bearbeiten,
  - Auflisten,
  - ggf. Absagen.
- Dient als Br√ºcke zwischen Terminplanung und Discord-eigenen Event-Funktionen.

13.2 M√∂gliche Features
----------------------
- `/events create`:
  - Name, Beschreibung, Start/Ende, Ort,
  - erstellt natives Discord-Event.
- `/events list`:
  - bevorstehende Events,
  - optional Filter nach Typ/Datum.
- `/events edit`:
  - √Ñnderungen an bestehenden Events (berechtigte Rollen).
- `/events cancel`:
  - Event absagen, mit optionaler Info-Nachricht.

13.3 Integration mit anderen Modulen
------------------------------------
- `reminder`:
  - kann basierend auf Events Reminder erstellen.
- `poll`:
  - kann vor Events zur Abstimmung (z. B. Spielauswahl) genutzt werden.
- `stream`:
  - Verbindung zwischen Events und Streams (z. B. Event wird gestreamt).

13.4 Berechtigungen, Logging & Stats
------------------------------------
- Nur bestimmte Rollen (z. B. Orga/Mods/Admins) d√ºrfen Events erstellen/√§ndern.
- Logging:
  - Erstellung, √Ñnderung, Absage.
- Stats:
  - Anzahl Events,
  - Nutzung von Event-Funktionen.

==================================================
14. FUNKTION `reminder` (GEPLANT)
==================================================

14.1 Ziel
---------
- `reminder` verwaltet Termine & Erinnerungen:
  - Geburtstage,
  - pers√∂nliche Reminder,
  - Server-/Community-Reminder.
- Geburtstage sind ein Spezialfall von Terminen.

14.2 Anwendungsf√§lle
--------------------
- User-Reminder:
  - ‚ÄûErinnere mich in 2 Wochen an X.‚Äú
- Server-Reminder:
  - ‚ÄûErinnere den Server jeden Montag an die Montagsrunde.‚Äú
- Geburtstage:
  - User kann optional seinen Geburtstag hinterlegen,
  - Server kann konfigurieren, ob/wo Geburtstagsgr√º√üe erscheinen.

14.3 Datenschutz & sensible Daten
---------------------------------
- Geburtstage sind personenbezogene Daten.
- Regeln:
  - Speicherung nur bei explizitem Opt-in,
  - User kann Geburtstag jederzeit l√∂schen,
  - Server kann entscheiden:
    - ob Geburtstags-Posts aktiviert sind,
    - in welchem Channel diese erscheinen,
    - ob Namen genannt werden oder anonymisiert.

14.4 Integration mit Settings
-----------------------------
- `serverSettings.functions.reminder.spezifisch`:
  - `geburtstagsChannelId?: string`
  - `geburtstagsPostsAktiv: boolean`
  - `standardReminderChannelId?: string`
- `userSettings.pr√§ferenzen.reminder`:
  - `geburtstag?: string` (Datum),
  - `gebeGeburtstagPublicFrei: boolean`,
  - `dmErinnerungenAktiv: boolean`.

14.5 Benachrichtigungen
-----------------------
- M√∂gliche Kan√§le:
  - Channel-Nachrichten,
  - DMs,
  - Logs in speziellen Orga-Channels.
- Reminder-Typen sollten klar gekennzeichnet sein:
  - `geburtstag`, `eventErinnerung`, `customReminder`, etc.

14.6 Verbindung zu `events`
---------------------------
- `reminder` kann basierend auf `events` automatische Erinnerungen generieren:
  - z. B. 1 Stunde vor Event-Beginn.

==================================================
15. FUNKTION `stats` ‚Äì SERVER-PROFIL & SERVER-STATS (ERWEITERUNG)
==================================================

15.1 Ziel
---------
- `stats` liefert:
  - Bot-/Funktions-Statistiken,
  - ein Serverprofil (z. B. √ºber `/server` oder `/stats server`).

15.2 Server-Stats (aggregiert)
------------------------------
- Beispiele:
  - Anzahl Mitglieder,
  - aktive User in letzten X Tagen,
  - Anzahl Channels (Text/Voice/Threads),
  - Anzahl Commands gesamt,
  - meistgenutzte Funktionen (Polls, Randomizer, Stream...),
  - Event-/Reminder-Aktivit√§t (Anzahl Events, Anzahl Reminder).

15.3 `/server`- oder `/stats server`-Command
--------------------------------------------
- Zeigt ein Embed mit:

  - Server-Basisdaten:
    - Name, Icon, Erstellungsdatum,
    - ggf. Region/Features,
  - MEAT-spezifischen Infos:
    - wie viele Funktionen sind aktiv,
    - Gesamtzahl der Bot-Interaktionen,
    - Aktivit√§tsindikatoren (z. B. ‚Äûsehr aktiv‚Äú, ‚Äûruhig‚Äú).

- Darstellung:
  - mit `stats`-Modul-Icon,
  - Farben aus `module-styles.ts`,
  - strukturierte Sections.

15.4 Integration mit Stats-Infrastruktur
----------------------------------------
- `stats` aggregiert Ereignisse, die √ºber `stats-manager` gemeldet wurden.
- Personenbezogene Informationen werden f√ºr Serverprofil nur aggregiert benutzt.

==================================================
16. BERECHTIGUNGEN & ROLLENSTEUERUNG
==================================================

16.1 Ziel
---------
- Berechtigungen (‚ÄûWer darf was?‚Äú) werden:
  - zentral,
  - pro Server,
  - konsistent gesteuert.

16.2 Speicherort
----------------
- Berechtigungen sind Teil von `ServerEinstellungen`.
- Zus√§tzlich k√∂nnen zentrale Dateien existieren:
  - `permissions-schema.ts`,
  - `permissions-helper.ts`.

16.3 Struktur (logisch)
-----------------------
- pro Funktion:
  - `serverSettings.functions.<funktion>.erlaubteRollenIds?: string[]`
    - Rollen, die diese Funktion nutzen d√ºrfen.
- globaler Block, z. B.:
  - `serverSettings.berechtigungen`:
    - `adminRollenIds: string[]`
    - `modRollenIds: string[]`
    - `orgaRollenIds: string[]`
    - funktions√ºbergreifende Flags (z. B. ‚Äûdarf Events erstellen‚Äú, ‚Äûdarf Vault nutzen‚Äú, ‚Äûdarf Sentinel konfigurieren‚Äú).

16.4 Zentraler Berechtigungs-Helper
-----------------------------------
- Statt inline-Abfragen:
  - Funktionen rufen z. B. `pruefeBerechtigung(funktion, aktion, user, serverSettings)` auf.
- Dieser Helper kombiniert:
  - Discord-Permissions,
  - globale Rollen-Konfiguration,
  - Funktions-spezifische `erlaubteRollenIds`.

==================================================
17. FUNKTION `ranks` (RANG-/LEVEL-/ACHIEVEMENT-SYSTEM, GEPLANT)
==================================================

17.1 Ziel
---------
- `ranks` bildet ein Progressionssystem:
  - R√§nge/Level basierend auf Aktivit√§t und besonderen Aktionen,
  - Achievements/Badges,
  - starke Verkn√ºpfung mit `user`, `stats`, `connect`, `league`, `steam`.

17.2 Datenbasis
---------------
- Nutzt `stats`-Daten:
  - Anzahl genutzter Funktionen,
  - Teilnahme an Events/Polls,
  - besondere Events (z. B. ‚Äûimmer bei Montagsrunde dabei‚Äú).
- Nutzt `connect`-Daten:
  - z. B. externe R√§nge oder Status:
    - League-Ranks (Iron‚ÄìChallenger),
    - Steam-Badges (Spielstunden, bestimmte Spiele),
    - Twitch-/YouTube-Status (Follower-/Sub-Ziele, Partner/Affiliate, sp√§ter optional).
- Personenbezogene Auswertungen nur mit Opt-in.

17.3 Anzeige
------------
- √úber `/ranks` oder integriert in `/user profil`:

  - MEAT-interne R√§nge:
    - z. B. Level 1‚Äì50, interne Titel.
  - Achievements:
    - Icons/Badges f√ºr spezielle Aktionen (Poll-King, Streamer, Dino-Meister, etc.).
  - externe R√§nge (wenn `connect`-Verkn√ºpfung und Freigabe):
    - League-Rang (z. B. ‚ÄûGold IV‚Äú),
    - Steam-Highlights (z. B. meistgespieltes Spiel),
    - Twitch-/YouTube-Badges (z. B. ‚ÄûStreamer auf diesem Server‚Äú).

- Darstellung:
  - modul-spezifisches Embed-Design,
  - Icons aus `icons.json`,
  - Farben aus `module-styles.ts`.

17.4 Integration mit `user`
---------------------------
- `user`-Profil-Embeds k√∂nnen:
  - `ranks`-Infos einbinden,
  - Badges/R√§nge im User-Profil anzeigen.
- `ranks` liefert Logik & Berechnungen,
- `user` k√ºmmert sich um die Pr√§sentation.

==================================================
18. FUNKTION `sentinel/monitoring` (SYSTEM-MONITORING, GEPLANT)
==================================================

18.1 Ziel
---------
- `sentinel/monitoring` √ºberwacht Systemgesundheit & Nutzung:
  - Auslastung,
  - Fehlerquote,
  - Aktivit√§t.

18.2 Kennzahlen
----------------
- Anzahl Commands/Interaktionen pro Zeitraum,
- Fehlerquote (Anteil `error`-Logs),
- durchschnittliche Antwortzeit,
- ggf. CPU-/Memory-Auslastung (sp√§ter),
- pro Funktion:
  - Nutzung vs. Fehler,
  - Aktivierung/Deaktivierung.

18.3 Darstellung & Zugriff
--------------------------
- Nur f√ºr berechtigte Rollen (z. B. Admin/Owner/Operator).
- Zugriff z. B. √ºber:
  - `/sentinel monitoring`,
  - `/meat status`.
- Ausgabe:
  - Embeds mit:
    - Ampelindikatoren (OK/Warnung/Kritisch),
    - Kennzahlen,
    - ggf. Hinweis auf Logs oder Web-Dashboards.

18.4 Integration mit Logging & Stats
------------------------------------
- `monitoring` nutzt:
  - Log-Daten (Abschnitt 5),
  - Stats-Daten (Abschnitt 6),
  um Health-Informationen abzuleiten.

18.5 Datenschutz
----------------
- Fokus auf technische & aggregierte Daten.
- Personenbezogene Infos (z. B. ‚ÄûTop-Nutzer‚Äú) nur bei Opt-in und nur, wenn konzeptionell wirklich n√∂tig.

==================================================
19. FUNKTION `einbuergerung` ‚Äì EINB√úRGERUNG & ‚ÄûVIRTUELLE NACHBARN‚Äú (GEPLANT)
==================================================

19.1 Ziel
---------
- `einbuergerung` bildet das Einb√ºrgerungs-/‚Äûvirtuelle Nachbarn‚Äú-System:
  - User k√∂nnen eine ‚ÄûEinb√ºrgerung‚Äú f√ºr einen Server beantragen,
  - nach Freigabe wird der Server zu ihrer ‚ÄûHeimatbasis‚Äú,
  - Rollen werden entsprechend angepasst,
  - anschlie√üend k√∂nnen sie sich ihren ‚Äûvirtuellen Nachbarn‚Äú vorstellen.

19.2 Grund-Flow
---------------
- Command (z. B. `/einbuergerung`), nur f√ºr User mit bestimmter Rolle erlaubt (konfigurierbar).
- Ablauf:
  1. Bot zeigt ein humorvolles MEAT-Embed mit Erkl√§rung der Einb√ºrgerung.
  2. Button ‚ÄûEinb√ºrgerung beantragen‚Äú √∂ffnet ein Modal mit Fragen (z. B. seit wann auf dem Server, Lieblingsgames, kurze Vorstellung).
  3. Antrag wird in einem Mod-/Orga-Channel als Embed gepostet:
     - Buttons: ‚ÄûAnnehmen‚Äú / ‚ÄûAblehnen‚Äú.
  4. Bei ‚ÄûAnnehmen‚Äú:
     - alte Rolle wird durch eine ‚Äûbessere‚Äú B√ºrger-/Heimat-Rolle ersetzt (konfigurierbar in `serverSettings`),
     - User erh√§lt eine kurze Best√§tigungsnachricht.

19.3 Vorstellung & ‚Äûvirtuelle Nachbarn‚Äú
---------------------------------------
- Nach erfolgreicher Einb√ºrgerung wird dem User ein Button angezeigt:
  - ‚ÄûM√∂chtest du dich deinen neuen virtuellen Nachbarn vorstellen?‚Äú
- Klick √∂ffnet ein weiteres Modal:
  - z. B. mit Feldern: Kurzvorstellung, Lieblingsspiele, Zeiten, in denen sie online sind.
- Ergebnis:
  - sch√∂n formatiertes Embed in einem konfigurierten Vorstellungs-Channel,
  - User soll seine Vorstellung sp√§ter bearbeiten k√∂nnen (z. B. √ºber einen `/user vorstellung`-Command oder Button ‚ÄûVorstellung bearbeiten‚Äú).

19.4 Settings & Berechtigungen
------------------------------
- In `serverSettings.functions.einbuergerung.spezifisch` k√∂nnen konfiguriert werden:
  - `antragsChannelId` (wo Mod-Antr√§ge landen),
  - `vorstellungsChannelId` (wo Vorstellungen gepostet werden),
  - `startRollenIds` (Rollen, die den Command nutzen d√ºrfen),
  - `neueBuergerRolleId` (Rolle, die der User bei Annahme erh√§lt),
  - optionale weitere Rollen- oder Tag-Optionen.
- Berechtigungen f√ºr Annahme/Ablehnung:
  - definierbar √ºber Rollen (`erlaubteRollenIds`) oder globale Berechtigungen (`serverSettings.berechtigungen.orgaRollenIds`, `adminRollenIds`).

19.5 Logging & Stats
--------------------
- Logging:
  - Einb√ºrgerungsantr√§ge,
  - Annahmen/Ablehnungen,
  - Fehlversuche (z. B. fehlende Berechtigungen).
- Stats:
  - aggregiert:
    - wie viele Einb√ºrgerungen gestellt/angenommen/abgelehnt wurden,
    - Anteil Einb√ºrgerungen pro Server/User (personenbezogen nur mit Opt-in).

==================================================
20. WEB-DASHBOARD, AUTH & UI-GRUNDS√ÑTZE (HIGH LEVEL, GEPLANT)
==================================================

20.1 Ziel
---------
- Das Web-Dashboard ist die visuelle Schaltzentrale f√ºr:
  - Server-Admins/Owner:
    - Server ausw√§hlen,
    - Funktionen (pro Server) aktivieren/deaktivieren,
    - Berechtigungs-Matrix pflegen,
    - Server-Settings anpassen,
    - Stats & Monitoring sehen.
  - Normale User:
    - eigenes Profil & Achievements sehen,
    - eigene Datenschutz-/Opt-in-Einstellungen verwalten,
    - eigene Connect-/Stream-Einstellungen sehen.
  - Globale Admins/Bot-Owner:
    - alle Server & globalen Einstellungen sehen,
    - globale Statistiken, Patchnotes, Botstatus etc.

20.2 Authentifizierung (Discord Login)
--------------------------------------
- Login ausschlie√ülich √ºber Discord OAuth2:
  - User meldet sich mit seinem Discord-Account an.
- Nach Login:
  - Das Backend kennt:
    - Discord-User-ID,
    - alle Guilds, in denen der User Mitglied ist,
    - innerhalb dieser Guilds die Rollen/Permissions (soweit API es erlaubt).
- Rechte:
  - Server-Admins/Owner:
    - d√ºrfen das Dashboard f√ºr ihre Guild(s) sehen und Einstellungen vornehmen.
  - Normale User:
    - sehen nur eigene User-Daten & server√ºbergreifende Informationen, soweit relevant.
  - Globale Admins/Bot-Owner:
    - in `GlobaleEinstellungen.globalAdmins` hinterlegt,
    - d√ºrfen alle Guilds und globale Bereiche sehen.

20.3 Server-Auswahl & Dashboard-Routing
---------------------------------------
- Wenn ein User NUR auf einem zul√§ssigen Server (Whitelist) Server-Admin/Owner ist:
  - landet er direkt auf dem Dashboard dieses Servers.
- Wenn ein User auf MEHREREN zul√§ssigen Servern Admin/Owner ist:
  - sieht er eine Auswahlseite (‚ÄûServer-Auswahl‚Äú),
  - kann einen Server w√§hlen (z. B. Cards mit:
    - Server-Icon,
    - Name,
    - Kurzinformationen).
- Server-Switch:
  - oben rechts ist das Discord-Profilbild des eingeloggten Users sichtbar.
  - daneben gibt es einen Server-Switch:
    - zeigt das aktuelle Server-Icon + Name an,
    - Dropdown/Overlay mit Liste der anderen Server, auf denen der User berechtigt ist.
- ‚ÄûIch kann alles sehen‚Äú:
  - globale Admins (z. B. Bot-Owner) sehen in der Server-Auswahl ALLE freigegebenen Server,
  - k√∂nnen zwischen ihnen wechseln, ohne separate Einladungen.

20.4 Dashboard-Hauptseite (f√ºr Server-Admins)
---------------------------------------------
- Layout:
  - UI basiert auf Tailwind CSS,
  - Dark-Mode by default,
  - klare, moderne, aufger√§umte Optik.
- Kopfzeile:
  - links oben:
    - Avatar des ausgew√§hlten Discord-Servers,
    - daneben Server-Name,
  - rechts oben:
    - Profilbild des eingeloggten Discord-Users,
    - kleiner Name/Tag,
    - ggf. Men√º/Dropdown f√ºr Account-Aktionen (Logout, Profil).
- Hauptbereich:
  - Cards (‚ÄûKacheln‚Äú) mit den wichtigsten Infos:
    - Card ‚ÄûAllgemeine Stats‚Äú:
      - z. B. Anzahl User, Anzahl aktiver Funktionen, Aktivit√§t der letzten Tage,
      - visualisiert mit Diagrammen (z. B. Bar/Line-Charts).
    - Card ‚ÄûDiscord-Widget‚Äú:
      - eingebettetes Discord-Widget des Servers (sofern aktiviert),
      - zeigt Online-User, Channels etc.
    - Card ‚ÄûBot-Status‚Äú:
      - Statusbild (z. B. Bot-Avatar),
      - Online/Offline-Status,
      - Ping/Latenz,
      - Uptime,
      - Link zum Bot-Discord/Support-Server.
    - Card ‚ÄûNeue Funktion‚Äú:
      - Teaser f√ºr neue Features,
      - kurzer Text,
      - Links zu Dokumentation/Changelog,
      - ggf. ‚ÄûJetzt aktivieren‚Äú-Button f√ºr bestimmte Funktionen.

20.5 Navigationsmen√º & Seiten
-----------------------------
- Linkes Hauptmen√º (f√ºr Server-Admins/Owner):
  - **Dashboard**:
    - Startseite mit oben beschriebenen Cards & Charts.
  - **Statistiken**:
    - detailliertere Charts:
      - Funktions-Nutzung,
      - Aktivit√§tsverl√§ufe,
      - Fehlerquoten (aggregiert).
    - Filter nach Zeitraum & Funktion.
  - **Berechtigungen**:
    - Rechte-Matrix:
      - welche Rollen d√ºrfen welche Funktionen nutzen,
      - wer darf Einstellungen √§ndern,
      - einfache, visuelle Matrix (Rollen x Funktionen) mit Toggles.
  - **Settings**:
    - Server-Settings:
      - Sprache,
      - Standard-Einstellungen pro Funktion (`functions.<funktion>.aktiv`, Log-Channels, Stats-An/Aus, etc.),
      - Sentinel-Einstellungen (Spam-/Raid-/Warnsystem-Schalter),
      - spezifische Parameter (z. B. Poll-Channel, Stream-Channel, Reminder-Channel).
  - **Global Settings** (nur f√ºr globale Admins/Bot-Owner sichtbar):
    - Einladungspolitik,
    - globale Stats/Monitoring,
    - Liste aller registrierten Server,
    - globale Feature-Flags.
  - **Info**:
    - Bot-Status und weitere Infos,
    - Infos zum Bot (z. B. ‚Äû√úber M.E.A.T.‚Äú),
    - Infos zum Entwickler / zu dir,
    - Patchnotes & Versionen:
      - k√∂nnen z. B. aus Git-Commits/Tags gezogen oder manuell gepflegt werden.

- Men√º f√ºr normale User (nicht-Admin, nicht-Owner):
  - **Dashboard**:
    - personalisierte √úbersicht:
      - z. B. eigene Aktivit√§t, kurze Serverinfos.
  - **Statistiken**:
    - eigene Stats (z. B. wie oft Polls genutzt, Teilnahme an Events),
    - Visualisierung der eigenen Aktivit√§t (nur bei Opt-in).
  - **Settings**:
    - eigene Datenschutz-/Opt-in-Einstellungen,
    - eigene Pr√§ferenzen (z. B. Sprache, Reminder-Einstellungen),
    - Connect-Einstellungen (welche externen Accounts sind verkn√ºpft, Sichtbarkeit).
  - **Profil** (kann unter Dashboard/Statistiken integriert oder als eigener Punkt gef√ºhrt werden):
    - eigene Discord-Infos,
    - MEAT-R√§nge & Achievements (`ranks`),
    - verkn√ºpfte Accounts (`connect`),
    - ‚ÄûUser-Profil-Card‚Äú in stylischer Darstellung.
  - **Info**:
    - allgemeine Bot-Infos,
    - Datenschutz-Hinweise,
    - ggf. Hinweise, wie man Admins f√ºr weitere Features anspricht.

20.6 Funktionstoggles im Dashboard
----------------------------------
- Jede Funktion (`functions.<funktion>`) ist:
  - im Dashboard sichtbar (sofern global freigegeben),
  - pro Server aktivierbar/deaktivierbar.
- Darstellung:
  - Liste oder Grid mit Cards:
    - Icon & Name der Funktion,
    - kurze Beschreibung,
    - Schalter ‚Äûaktiv/inaktiv‚Äú,
    - ggf. Link ‚ÄûDetails‚Äú ‚Üí Unterseite mit detaillierten Settings f√ºr diese Funktion.
- √Ñnderungen am Toggle:
  - werden direkt in `serverSettings.functions.<funktion>.aktiv` gespeichert,
  - wirken sofort auf den Bot (Commands & Events pr√ºfen diesen Wert).

20.7 UI/UX-Grunds√§tze (Web)
---------------------------
- Visuelle Leitlinien:
  - Tailwind CSS,
  - Dark-Mode Standard,
  - farbige, aber nicht √ºberladene Graphen (Farben pro Funktion/Modul konsistent),
  - gro√üz√ºgige Abst√§nde, klare Hierarchien, keine √ºberfrachteten Screens.
- User Experience:
  - Startseite zeigt die wichtigsten Infos in 3‚Äì6 Kern-Cards,
  - tiefergehende Einstellungen auf separaten Tabs/Seiten, nicht alles auf einer Page,
  - klare Hinweise, wenn man keine Rechte f√ºr einen Bereich hat (‚ÄûDu brauchst Rolle X, um das hier zu sehen‚Äú).
- Sicherheit & Feedback:
  - kritische √Ñnderungen (z. B. Funktionen komplett deaktivieren, Sentinel-Settings) erfordern ggf. eine Best√§tigungsabfrage,
  - bei erfolgreichen √Ñnderungen kurzes, klares Feedback (Toast/Alert).
- Responsives Design:
  - Dashboard funktioniert auf Desktop optimal,
  - auf kleineren Ger√§ten (Tablet/Laptop) skalieren die Cards & Navigation sinnvoll.


==================================================
21. COMMUNITY HUB & CLIP-QUEUE (GEPLANT)
==================================================

21.1 Ziel
---------
- Der Community Hub b√ºndelt Community-bezogene Funktionen (Clips, Events, Leaderboards, Member Wall, Feedback) an einer Stelle ‚Äì sowohl im Web als auch im Bot.
- Die Clip-Queue ist die erste zentrale Funktion im Community Hub:
  - Alle kurzformatigen Clips (Twitch, YouTube Shorts, Reels, Shorts, Stories) aus einem festgelegten Discord-Channel werden automatisiert gesammelt.
  - Clips k√∂nnen bewertet, gefiltert und in einer ‚ÄûWatch-Queue‚Äú im Web nacheinander angesehen werden.
  - User sehen, welche Clips neu, ungesehen oder bereits gesehen sind.
  - Die Clip-Queue dient als Grundlage f√ºr ‚ÄûBest-of‚Äú-Auswertungen (z. B. Monats-Highlights, Video-Ideen).

21.2 Community Hub ‚Äì Men√º & Struktur (Web)
------------------------------------------
- Im Web-Dashboard gibt es einen eigenen Navigationspunkt:

  - Community Hub (Hauptpunkt im Men√º)

    Geplante Unterbereiche:
    - Clip-Queue (Clips & Highlights)
    - Events (Community-Termine, Montagsrunde etc.)
    - Leaderboards (Punkte, Aktivit√§t, Rankings)
    - Member Wall (Vorstellungen, Hall of Fame)
    - Feedback (Ideen, Bugs, Umfragen)

- Die Clip-Queue ist eine Unterseite des Community Hub und fokussiert sich ausschlie√ülich auf kurzformatige Video-Clips.

21.3 Clip-Quelle (Discord-Channel & Plattformen)
------------------------------------------------
- Alle Clips werden √ºber einen fest definierten Discord-Channel eingesammelt, z. B. #clips oder #clip-queue.
- Nur kurze Clips sind erlaubt, z. B.:
  - Twitch Clips
  - YouTube Shorts / kurze YouTube-Links
  - Instagram Reels
  - Instagram Stories (sofern sinnvoll einbindbar)
  - optional sp√§ter: TikTok, andere Short-Form-Plattformen

- Grundregel:
  - Nur Short-Form-Content, keine kompletten VODs, keine langen Streams.
- Jede Discord-Nachricht in diesem Channel, die eine g√ºltige Clip-URL enth√§lt, erzeugt (nach Validierung) einen Clip-Eintrag im System.

21.4 Datenmodell `Clip` (logisch)
---------------------------------
- Logisches Datenmodell f√ºr einen Clip (ohne konkrete TS-Definition, nur Struktur):

  - id: string
    - interne Clip-ID

  - url: string
    - Normalisierte Clip-URL (z. B. ohne Tracking-Parameter)
    - Dient als Prim√§rschl√ºssel zur Deduplizierung (keine doppelten Clips)

  - plattform: 'twitch' | 'youtube' | 'instagram' | 'tiktok' | 'sonstigeShorts'
    - Erkannt anhand der URL, f√ºr Einbettung & Darstellung

  - titel: string
    - Standardm√§√üig: aus der Discord-Nachricht oder aus der Plattform-API gelesen
    - Optional √ºberschreibbar (z. B. √ºber Web-UI oder Mod-Tools)

  - spielOderKategorie: string
    - z. B. "League of Legends", "ARK", "Just Chatting", "IRL", "Community"

  - eingereichtVon (Submitter-Liste, mit Opt-in):
    - erstEinreicherId: string | null
    - weitereEinreicherIds: string[]
    - Anzeige im UI:
      - Nur, wenn personenbezogenes Tracking und Namensanzeige erlaubt sind (siehe 21.8).
      - Ansonsten: Anzeige als "(anonym)".

    - Mehrfach-Einreichungen derselben URL f√ºhren nicht zu neuen Clip-Eintr√§gen, sondern erweitern nur weitereEinreicherIds.

  - votes: { emoji: string; anzahl: number }[]
    - Liste von genutzten Bewertungs-Reactions bzw. Web-Votes:
      - z. B. [ { emoji: 'üî•', anzahl: 12 }, { emoji: 'üòÇ', anzahl: 5 } ]
    - Dient als Basis f√ºr ‚ÄûTop-Clips‚Äú, ‚ÄûHidden Gems‚Äú etc.

  - erstelltAm: string (ISO-Datum)
    - Zeitpunkt, wann der Clip ins System aufgenommen wurde (erste Einreichung)

- Eventbezug:
  - Aktuell kein festes Feld f√ºr Event-Bezug vorgesehen (z. B. kein Pflicht-Link zu einem Event).
  - Sp√§ter optional erweiterbar √ºber generische Tags/Kategorien, falls n√∂tig.

21.5 User-spezifischer Seen-Status & Badges
-------------------------------------------
- Der Seen-Status ist grunds√§tzlich user-spezifisch und wird nicht direkt im Clip selbst gespeichert, sondern als separate View-Tabelle (z. B. in einer ClipView-Entit√§t):

  - userId: string
  - clipId: string
  - gesehenAm?: string (ISO-Datum, optional)

- Im UI werden pro Clip (rechts in der Queue-Liste und ggf. im gro√üen Player-Bereich) folgende Badges angezeigt:

  - üü¢ Ungesehen
    - Der aktuelle User hat diesen Clip noch nie oder noch nicht als ‚Äûgesehen‚Äú markiert.

  - ‚ö´ Gesehen
    - Der aktuelle User hat diesen Clip bereits gesehen (automatisch oder manuell markiert, siehe unten).

- Zus√§tzlich gibt es einen globalen ‚ÄûNEU‚Äú-Badge unabh√§ngig vom User:

  - z. B. "NEU" f√ºr Clips, deren erstelltAm nicht √§lter als 7 Tage ist.
  - Darstellung z. B. als zus√§tzlicher, farbiger Badge ("NEU" / "NEW") neben dem Seen-Status.

- Seen-Markierung:
  - Automatisch:
    - Ein Clip wird nach einem sinnvollen Schwellwert (z. B. 80 % abgespielt oder X Sekunden Mindestansicht) als ‚Äûgesehen‚Äú markiert.
  - Manuell:
    - Der User kann einen Clip explizit als ‚Äûgesehen‚Äú markieren (z. B. Button oder UI-Element ‚ÄûAls gesehen markieren‚Äú).

21.6 Filter & Sortierung in der Clip-Queue (Web)
-------------------------------------------------
- In der rechten Queue-Spalte stehen oben Filter & Sortierung zur Verf√ºgung, z. B.:

  - Filter ‚ÄûAnsicht‚Äú:
    - "Alle Clips"
    - "Nur ungesehene Clips"
    - "Nur neue Clips" (z. B. erstelltAm ‚â§ 7 Tage)

  - Zeitraum-Filter:
    - "Dieser Monat"
    - "Letzter Monat"
    - "Alle"

  - Sortierung:
    - "Neueste zuerst"
    - "Meist gevotet" (z. B. nach votes-Summe)
    - "Zuf√§llig" (Shuffle-Mode f√ºr Binge-Feeling)

- Filter ‚ÄûNur ungesehene Clips‚Äú nutzt den user-spezifischen Seen-Status (siehe 21.5) und blendet Clips aus, die der User bereits gesehen hat.
- Filter ‚ÄûNur neue Clips‚Äú nutzt ausschlie√ülich erstelltAm und ist unabh√§ngig vom pers√∂nlichen Seen-Status.

21.7 Queue-Verhalten & Navigation
---------------------------------
- Layout (nur konzeptionell, kein HTML):
  - Links: gro√üer Player mit dem aktuell ausgew√§hlten Clip.
  - Rechts: scrollbare Liste (Queue) mit den Clips entsprechend Filter/Sortierung.
  - Unten unter dem Player: Navigation und Bedienelemente.

- Verhalten beim Navigieren:
  - Buttons unter dem Player:
    - "Zur√ºck" ‚Üí vorheriger Clip in der aktuellen, gefilterten Queue.
    - "Weiter" ‚Üí n√§chster Clip in der aktuellen, gefilterten Queue.
  - Optional:
    - Toggle "Auto-Play" ‚Üí n√§chster Clip wird automatisch geladen, sobald der aktuelle abgeschlossen ist.
    - Button "Zur√ºck zum Anfang" ‚Üí springt zum ersten Clip der aktuellen Filter-/Sortier-Kombination.

- Interaktion mit Seen-Status:
  - Im Modus "Nur ungesehene Clips":
    - Nach dem Abspielen wird der aktuelle Clip als "gesehen" markiert und aus der Liste entfernt.
    - Der n√§chste Clip r√ºckt automatisch nach und wird zum neuen aktuellen Clip.
  - Im Modus "Alle Clips":
    - Der Clip erh√§lt lediglich das Badge ‚ö´ Gesehen, bleibt aber in der Liste sichtbar.

21.8 Datenschutz, Opt-in & Anzeige ‚ÄûEingereicht von‚Äú
----------------------------------------------------
- Eingereichte Clips & User-Namen:
  - Ein Clip kann von mehreren Usern eingereicht worden sein (erstEinreicherId, weitereEinreicherIds).
  - Die Anzeige im UI erfolgt abh√§ngig von Datenschutz-/Tracking-Settings:

    - Wenn Server-Tracking und User-Tracking erlaubt sind:
      - Anzeige im Stil:
        - "Eingereicht von User 1"
        - "Eingereicht von User 1 & 2 weiteren"
      - Konkrete Usernamen oder Nicknames d√ºrfen genutzt werden.

    - Wenn kein Opt-in oder Tracking deaktiviert:
      - Einreichende User werden nicht namentlich genannt.
      - Anzeige stattdessen als "(anonym)" oder neutraler Text (z. B. "Community-Einreichung").

- Seen-Status & Tracking:
  - User-spezifische ClipView-Eintr√§ge (Seen-Status) sind personenbezogene Daten.
  - Speicherung nur, wenn:
    - serverSettings.datenschutz.userTrackingErlaubt = true UND
    - userSettings.datenschutz.trackingErlaubt = true.
  - Wenn eine dieser Bedingungen nicht erf√ºllt ist:
    - Es wird kein pers√∂nlicher Seen-Status gespeichert.
    - Die Queue kann weiterhin globale "NEU"-Badges nutzen, aber keine üü¢/‚ö´-Unterscheidung pro User.

- Anbindung an Sentinel:
  - Datenschutz-Logik der Clip-Queue h√§ngt an sentinel/datenschutz (Opt-in/Opt-out, siehe bestehende Sentinel-Regeln).

21.9 Logging & Statistiken (Clip-Queue)
---------------------------------------
- Logging (aggregiert, keine sensiblen Inhalte im Volltext):
  - Wann Clips neu aus Discord importiert werden (mit Kontext: Guild, Channel, Plattform).
  - Fehler bei der URL-Erkennung oder Plattform-Validierung.
  - Nutzung der Web-Queue (z. B. wie viele Clips in einem Zeitraum angesehen wurden, ohne personenbezogene Details).

- Stats (√ºber stats-manager):
  - Aggregiert:
    - Anzahl Clips pro Zeitraum und Plattform (Twitch/YouTube/Instagram).
    - Anzahl Views pro Clip (gesamt).
    - Anzahl Votes pro Clip / pro Plattform.
    - Aktivit√§t im Clip-Channel (z. B. wie viele Einreichungen pro Woche).
  - Personenbezogene Stats (nur bei Opt-in):
    - Wie viele Clips ein User gesehen hat.
    - Optional: Beteiligung an Votes oder Einreichungen.

21.10 Ort im Projekt (Bot & Web)
--------------------------------
- Bot-seitig (Clip-Erfassung & Votes):
  - Geplantes Modul unter:
    - src/bot/functions/video/
      oder
    - src/bot/functions/clips/
  - Aufgaben:
    - Nachrichten im festgelegten Clip-Channel auswerten, URLs validieren, Clip-Eintr√§ge anlegen.
    - Reactions/Votes auf Clip-Nachrichten auswerten und auf das votes-Feld abbilden.
    - Optional: Commands/Buttons f√ºr Moderation (z. B. Clip sperren, Titel anpassen).

- Web-seitig (Community Hub & Clip-Queue):
  - Geplante Routen, z. B.:
    - web/community/hub ‚Üí Community Hub √úbersicht
    - web/community/clip-queue ‚Üí Clip-Queue-Ansicht mit Player + Queue
  - Zugriff √ºber Discord-Login (siehe Abschnitt "Web-Dashboard & Auth").

==================================================
22. WEITERE COMMUNITY- & DISCORD-FEATUREMODULE (IDEEN, GEPLANT)
==================================================

Hinweis: Dieser Abschnitt sammelt geplante Feature-Ideen, die mit discord.js technisch gut umsetzbar sind.
Jede Idee soll sp√§ter bei Umsetzung die Funktions-Planungs-Checkliste (Abschnitt 9) durchlaufen und ein eigenes Modul unter src/bot/functions/ erhalten.

22.1 Tickets & Support
----------------------
- Modul-Idee: src/bot/functions/tickets/
- Funktionen (geplant):
  - Support-Tickets:
    - User klickt auf einen Button ‚Üí Bot erstellt Ticket-Channel/Thread.
    - Kategorie-Auswahl (Technik, Orga, Bewerbung etc.) per Select-Men√º.
    - Auto-Logging beim Schlie√üen (Status, Grund, Bearbeiter).
  - Onboarding-/Bewerbungs-Formulare:
    - Bewerbung f√ºr Mod-/Team-Rollen via Modal.
    - Reviews in Mod-Channel mit Buttons ‚ÄûAnnehmen‚Äú / ‚ÄûAblehnen‚Äú / ‚ÄûNachfragen‚Äú.
  - Bug-/Feature-Tracker:
    - Meldungen aus Discord werden gesammelt, kategorisiert und k√∂nnen im Web oder via Interface geordnet ausgewertet werden.

22.2 Economy, XP & Progression
------------------------------
- M√∂gliche Module:
  - src/bot/functions/economy/
  - src/bot/functions/quests/ (oder integriert in ranks/user)

- Features (geplant):
  - Server-W√§hrung:
    - Coins / Punkte f√ºr Aktivit√§t, Events, Siege, Votings.
    - Shop-Command (Rollen, Titel, kosmetische Dinge wie Profil-Titel, spezielle Sounds).
  - XP & Level-System (verzahnt mit ranks):
    - XP f√ºr Messages, Voice-Minuten, Event-Teilnahmen (mit Anti-Spam-Logik).
    - Level-Up-Rollen oder besondere Rechte.
  - Quests & Aufgaben:
    - Daily/Weekly-Quests (‚Äûschreibe 5 sinnvolle Nachrichten im Help-Channel‚Äú, ‚Äûnimm an einem Event teil‚Äú).
    - Belohnungen in Form von XP, Coins, Badges.

22.3 Content- & Media-Automation
--------------------------------
- M√∂gliche Module:
  - src/bot/functions/news/
  - src/bot/functions/announcements/ (oder Erweiterung von stream/video)

- Features (geplant):
  - Auto-News & Feeds:
    - YouTube/Twitch/Blog/RSS-Feeds ‚Üí automatische Posts in News-Channels mit Embeds.
  - Clip-/Highlight-Sammelfunktionen (Erweiterung zur Clip-Queue):
    - Voting f√ºr ‚ÄûClip des Monats‚Äú direkt in Discord.
    - Sammeln von ‚ÄûHighlight‚Äú-Kandidaten f√ºr Video-Schnitt (z. B. Web-Export-Liste).
  - Release-/Patchnotes-Bot:
    - Automatisierte Ver√∂ffentlichung von DevLogs/Changelogs im Discord.

22.4 Admin-Tools & Analyse
--------------------------
- Modul-Idee: src/bot/functions/admin-tools/ oder Integration in stats/sentinel/monitoring.

- Features (geplant):
  - Server-Health & Analyse:
    - Welche Channels werden aktiv genutzt, welche sind ‚Äûtot‚Äú?
    - Peak-Zeiten & Aktivit√§tsheatmaps.
  - Permission-Check:
    - /rechte @user zeigt effektiv vererbte Rechte & Rollen kompakt an.
  - Config-Shortcuts:
    - Botside-Commands zur Anpassung von serverSettings, z. B. Poll-Channel setzen, Stream-Channel setzen, ohne Web-Dashboard √∂ffnen zu m√ºssen.

22.5 Voice- & Live-Features
---------------------------
- M√∂gliche Module:
  - src/bot/functions/voice/
  - Erweiterungen in events, stream, reminder.

- Features (geplant):
  - Temp-Voice-Channels:
    - User klickt ‚ÄûEigener Channel‚Äú ‚Üí Bot erstellt tempor√§ren Voice-Channel, l√∂scht ihn bei Inaktivit√§t wieder.
  - Voice-Stats:
    - Erfassung von Voice-Minuten/Teilnahmen (aggregiert, mit Opt-in f√ºr personenbezogen).
  - Live-Monitoring & Overlays:
    - Aggregierte Voice-/Event-Daten k√∂nnen per Webhook f√ºr Stream-Overlays bereitgestellt werden (z. B. ‚ÄûAktive Nutzer gerade im Voice‚Äú).

22.6 KI- / Smart-Features (erg√§nzend zu ai)
-------------------------------------------
- Erweiterungen innerhalb von src/bot/functions/ai/ und Tools:

- Features (geplant):
  - Smart-Reply / Auto-Suggest:
    - Nachrichtenerkennung ‚Üí Bot schl√§gt Buttons, Commands oder Hilfe-Artikel vor, statt immer eine Komplett-Antwort zu generieren.
  - FAQ-/Knowledge-Base-Suche:
    - User-Fragen k√∂nnen √ºber Tools auf interne Docs/FAQ/Confluence/JSON zugreifen und passende Antworten inkl. Links liefern.
  - Context-Aware-Mentions:
    - @MEAT nutzt nicht nur Text, sondern auch Tools (Poll-Status, Events, Stats), um wirklich kontextbezogen zu antworten.

22.7 Multi-Server- & Netzwerk-Features
--------------------------------------
- M√∂gliche Module / Erweiterungen:
  - src/bot/functions/network/
  - Erg√§nzungen in stats, events, ranks.

- Features (geplant):
  - Global-Stats & Netzwerk-√úbersicht:
    - Aggregierte Nutzung √ºber mehrere Server hinweg (f√ºr Bot-Owner).
  - Cross-Server-Events:
    - Ank√ºndigungen/Events, die gleichzeitig in mehreren Servers gepostet werden k√∂nnen.
  - Shared-Leaderboards:
    - Globale Rankings (z. B. ‚ÄûTop-Voter‚Äú, ‚ÄûTop-Event-Teilnehmer‚Äú) √ºber mehrere Communities, nur sichtbar f√ºr freigegebene Server.

22.8 UX- / Politur-Features
---------------------------
- Querschnittsfunktionen, die die User Experience verbessern, unabh√§ngig vom Modul:

  - Reaktions-Macros:
    - Bestimmte Phrasen (z. B. ‚ÄûBot Bug‚Äú) triggern selten, aber gezielt MEAT-typische Antworten + Feedback-Button.
  - User-Profile Cards (visuell):
    - Schicke, visuelle Profilkarten (z. B. Skill-Card, Community-Card) auf Basis von user, ranks, stats.
  - Seasonal Modes:
    - Saisonal aktivierbarer ‚ÄûWeihnachten-/Halloween-/Event‚Äú-Modus, der Farben, Icons und Tonalit√§t (leicht) anpasst.

Diese Abschnitte definieren die geplante Clip-Queue im Community Hub und markieren weitere sinnvolle, sp√§ter ausbaubare Module, die mit discord.js sehr gut realisierbar sind. Bei der tats√§chlichen Implementierung einzelner Module ist die Funktions-Planungs-Checkliste (Abschnitt 9) anzuwenden, inkl. Anbindung an Logging, Stats, Sentinel und Settings.




==================================================
VAULT-ERWEITERUNG: USER-NOTIZEN & GPT (VORMERKUNG)
==================================================

- F√ºr `vault` ist vorgesehen, sp√§ter auch ‚ÄûNotizen √ºber User‚Äú speichern zu k√∂nnen (Beispiele: bevorzugte Spiele, Orga-Infos, Rollenw√ºnsche).
- WICHTIGE REGEL:
  - Solche Notizen d√ºrfen NUR erstellt werden, wenn in der betreffenden Nachricht mindestens ein User √ºber @Mention genannt wird (`@Name`).
    - Ohne @Mention ‚Üí keine Speicherung, da Opt-in nicht gepr√ºft werden kann.
- Wenn mehrere User in einer Nachricht erw√§hnt werden:
  - k√∂nnen auch Beziehungen zwischen den genannten Usern gespeichert werden (z. B. ‚Äûspielt oft mit @UserA zusammen‚Äú),
  - jedoch gilt:
    - f√ºr **jeden** erw√§hnten User muss `userSettings.datenschutz.trackingErlaubt = true` sein,
    - der Server muss Tracking erlauben (`serverSettings.datenschutz.userTrackingErlaubt = true`).
  - Wenn mindestens einer der genannten User Tracking NICHT erlaubt (oder noch nicht entschieden hat),
    - wird die gesamte Vault-Notiz abgelehnt (keine Speicherung).
- Diese Daten gelten als personenbezogen; ein sp√§terer, eigener Vault-Regelabschnitt soll definieren:
  - welche Kategorien erlaubt sind,
  - wer Einsicht hat (Mods, User selbst, Admin),
  - wie L√∂schung und optionaler GPT-Zugriff geregelt sind.

==================================================
ENDE DER BASIS-REGELDATEI
==================================================

Dieses Dokument ist die zentrale Grundlage f√ºr den Neuaufbau des MEAT-Bots und des zugeh√∂rigen Dashboards.
Alles, was neu geplant und implementiert wird, soll sich daran orientieren.


Keine ausgew√§hltKeine ausgew√§hlt
ChatGPT kann Fehler machen. √úberpr√ºfe wichtige Informationen. Siehe Cookie-Voreinstellungen.
